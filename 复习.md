# 1.JS数据类型

一、Js一共有8种数据类型，其中：

​	7种基本数据类型：Undefined，Null，Boolean， Number，String，Symbol（es6新增，表示第一无二的值）和BigInt（es10新增。比Number数据类型支持的范围更大的整数值，和普通整数类型不同，typeof运算符对于BigInt类型的数据返回`bigint` ，用于计算大整数，不会出现整数溢出。）

  1种引用数据类型：Object，里面包含function，Array，Data等。

二、区别

​	原始数据类型：直接存储在栈中，占据空间小，大小固定，属于被频繁使用的数据，所以存放在栈中。

​	引用数据类型：同时存储在栈和堆中，占据空间大，大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中的地址。当解释器寻找引用值时，会首先检索在栈中的地址，拿到地址再从堆中获得数据。

# 2.逻辑运算符

一、&&

​	逻辑与，（1）连接多个表达式，一个为假则都为假

​					（2）连接的不一定是条件表达式，前面为真则取后面的值作为整个表达式的值，例： 1&&2   //2；前面为假则取前面的值，后面的不执行，例：0&&1  //0

​	逻辑或，（1）连接多个表达式，一个为真则都为真

​					（2）连接的不一定是条件表达式，前面为真则取前面的值，后面不执行。前面为假则取后面的值，前面的不执行。

​	！！ 可以将右侧的值强行转换为布尔值

# 3.js的数据类型的转换

类型转换只有三种情况，分别是：

​	转为布尔值（调用Boolean()方法）

​	转为数字（调用Number()、parseInt()和parseFloat()方法，后面两种可以从字符串中提取数字）

	var a = "123.45dsadas123"
	     parseInt(a)  ->   123
	     parseFloat(a) -> 123.45
​	转为字符串（ 调用.toString()或者String()方法 ）

 ![img](https://user-gold-cdn.xitu.io/2020/5/28/1725b947653323df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 

隐式转换：

​	同种数据类型之间的运算和比较：

​		Number：不需要转化
​			1/0 //Infinity       -1/0  // -Infinity
​			0/0 // NaN          1%0 // NaN            0%0   //NaN
​		String
​				运算： +  拼接字符串

​							/  -  %转化为数字类型， 结果都是NaN
​				比较： 比较的是字符的Unicode码，从左到右依次比较每							个字符，出现大小的结果就停止。
​		Boolean
​				转数字 0和1
​		undefined
​				转数字 NaN
​		null
​				转数字 0

​	不同种数据类型之间的运算和比较：

​		运算：除了+ ，在有字符串的时候是拼接，其余都是转数字

​		比较：都是转数字

注意：	

NaN和所有数据类型进行运算都是NaN，所有比较结果都是false，判等结果也都是false，包括本身。

判等，同种数据类型如果内容相等则相等，不同数据类型转数字

空字符串和null不等，false和null不等，0和null不等，undefined和null相等

# 4.js中数据类型的判断（typeof，instanceof，constructor，Object.prototype.toString.call()）

1.typeof

​	typeof对于基本数据类型来说，除了null都可以正确显示

​	console.log(typeof 2);               // number
​	console.log(typeof true);            // boolean
​	console.log(typeof 'str');           // string
​	console.log(typeof []);              // object     []数组的数据类型在 typeof 中被解释为 object
​	console.log(typeof function(){});    // function
​	console.log(typeof {});              // object
​	console.log(typeof undefined);       // undefined
​	console.log(typeof null);            // object     null 的数据类型被 typeof 解释为 object

​	**typeof对于对象来说，除了函数，都会显示object**，所以想判断一个对象的正确类型，考虑使用instanceof。

2.instanceof

​	console.log(2 instanceof Number);                    // false
​	console.log(true instanceof Boolean);                // false 
​	console.log('str' instanceof String);                // false  
​	console.log([] instanceof Array);                    // true
​	console.log(function(){} instanceof Function);       // true
​	console.log({} instanceof Object);                   // true    
​	**可以看出，instanceof可以精准判断引用数据类型，但是基本数据类型不能被精准判断。**

​	**instanceof用来测试一个对象在原型链中是否存在一个构造函数的prototype属性，，意思就是判断对象是否是某一数据类型的实例，但是基本数据类型不是实例，所以判断为false。**

3.constructor

​	console.log((2).constructor === Number); // true
​	console.log((true).constructor === Boolean); // true
​	console.log(('str').constructor === String); // true
​	console.log(([]).constructor === Array); // true
​	console.log((function() {}).constructor === Function); // true
​	console.log(({}).constructor === Object); // true

**注意： 如果创建一个对象，更改它的原型，constructor就会变得不可靠了** 

function Fn(){};

Fn.prototype=new Array();

var f=new Fn();

console.log(f.constructor===Fn);    // false

console.log(f.constructor===Array); // true 

4.Object.prototype.toString.call()

​	var a = Object.prototype.toString;

​	console.log(a.call(2)); 	//[object Number]
​	console.log(a.call(true));	//object Boolean]
​	console.log(a.call('str'));	//[object String]
​	console.log(a.call([]));	//[object Array]
​	console.log(a.call(function(){}));	//[object Function]
​	console.log(a.call({}));	//[object Object]
​	console.log(a.call(undefined));	//[object Undefined]
​	console.log(a.call(null));	//[object Null]

# 5.介绍js有哪些内置对象

​	全局的对象或称标准内置对象

​	标准内置对象的分类

​	1.值属性，这些全局属性返回一个简单值，没有自己的属性和方法

​		-Infinity，NaN，undefined，null

​	2.函数属性，全局函数可以直接调用，不需要指定所属对象，执行结束后会将结果直接返回给调用者。

​		-eval()，parseInt()，parseFloat()

​	3.基本对象，是定义或使用其他对象的基础，基本对象包括一般对象，函数对象和错误对象

​		-Object，Function，Boolean，Symbol，Error

​	4.数字和日期对象

​		-Number，Math，Date

​	5.字符串，用来表示和操作字符串

​		-String，RegExp

​	6.可索引的集合对象，包括数组和类数组，以及类数组结构的对象

​		-Array

​	7.使用键的集合对象，这些对象在存储数据会使用键，支持按照插入顺序来迭代对象

​		-Map(Map和Object的区别，Map中的键和值可以是任意类型；键值是有序的，遍历时按照插入顺序返回；通过size属性获取键值对个数；可迭代；在频繁增删键值对的场景下有性能优势)

​		-Set(生成类数组结构，值都是唯一的，可以用来数组去重)

​		-WeakMap、WeakSet 

​	8.结构化数据

​		-JSON

​	9.控制抽象对象

​		-Promise，Generator

# 6.undefined和undeclared的区别？

​	已在作用域声明但是没有赋值为undefined，未声明未赋值为 undeclared  。

​	对于undeclared变量的引用，浏览器会报引用错误， 如 ReferenceError: b is not defined 

# 7.null和undefined的区别？

​	都是基本数据类型。undefined表示未定义，null表示空对象。一般变量声明了但还未赋值的时候会返回undefined，null主要用于赋值一些可能会返回对象的变量，作为初始化。

​	注意：null不是对象，虽然typeof null会输出object，但是这是js存在的一个悠久的BUG。在JS最初版本中使用的是32位系统，为了性能考虑使用低位存储变量的类型信息，000开头代表对象，然而null表示为全零，所以将它判断为object。

# 8.{}和[]的valueOf和toString的结果是什么？

​	{}的valueOf结果为{}（自身，因为是非包装对象，没有基本值），toString的结果为 "[object Object]"

​	[]的valueOf结果为[]（自身，，因为是非包装对象，没有基本值），toString的结果为""（字符串）



//包装对象调用的valueOf和toString都是自己原型上的

//包装对象调用valueOf返回的是[[PrimitiveValue]]的值，

//包装对象调用toString就是把[[PrimitiveValue]]的值转化为字符串

 // 非包装对象（数组，函数，对象）调用的valueOf都是Object原型当中的，返回的都是自身

# 9.js的作用域和作用域链

​	作用域：作用域是定义变量的区域，有一套访问变量的规则，管理浏览器引擎在当前作用域以及嵌套的作用域中根据变量标识符进行变量查找。描述的是变量起作用的区域范围，以函数为界限，函数内部为局部作用域，外部为全局作用域，作用域是写好代码就确定好的。

​	作用域链：描述的是程序在找变量的过程，程序在查找变量时，先在自己作用域找，如果找不到就去上一级作用域找，如果一直找不到就报错。（引用错误，这个变量没有定义）。 作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。 

​	区别：作用域是抽象的，不存在，作用域链是存在的。



联系：全局变量和局部变量。

​	函数内部定义的局部变量只能在函数内部使用，函数外部看不到。

​	函数外部的全局变量，在函数内部可以使用。

​	碰到函数内部变量不带var时：

​		（1）先在函数内部找，如果有var a，则按局部变量处理，

​		（2）如果没有，那么去形参找看看有没有a这个变量，如果有，同样当局部变量处理，相当于内部写了var a

​		（3）如果没有，去函数外部全局作用域找，如果找到了，内部的a相当于在操作全局变量，如果没有，相当	于在全局定义了一个全局变量。

联系： 预解析

​	（1）先解析函数声明定义的函数，（2）解析带var的变量，（3）函数重名，后面会覆盖前面，变量重名会忽略变量，（函数声明定义，整个函数提升，表达式定义只提升变量）

```

```

联系：程序开始执行到结束都做了什么

​	（1）程序一开始执行，遇见了全局环境，首先会创建全局环境并进行压栈，全局代码执行的时候依赖全局环境，比如全局变量会直接存入栈中，如果是对象类型，数据在堆结构中开辟自己的空间，然后把地址存在栈中对应的变量身上。

​	（2）当程序遇到函数调用，函数执行时也需要依赖环境，因此创建函数环境进行压栈，一定是压在全局环境之上，局部变量是在函数环境当中存在的，只有函数执行，局部变量才会出现，函数执行完成后，函数环境要弹出栈（销毁归还内存）局部变量也就不存在了。

​	（3）当函数调用完成后，会继续执行全局代码，一直到所有的代码都执行完，全局环境最后出栈。

# 10.js创建对象的几种方式？

##### 1.工厂模式

```js
function createPerson(name,age){
	var o = new Object()
    o.name = name
    o.age = age
    o.sayName = function(){
        console.log(this.name)
    }
    return o
}
var person1 = createPerson('Tom',15)
```

优点：解决了创建多个相似对象时，代码复用的问题。

缺点：没有解决对象识别问题（怎样知道一个对象的类型是什么）

##### 2.构造函数模式

```js
funtion createPerson(name,age){
	this.name = name
    this.age = age
    this.sayName = function(){
        console.log(this.name)
    }
    return o
}
var person1 = new createPerson('Tom',15)
```

当使用构造函数实例化一个对象的时候，对象中会包含一个_proto_属性指向构造函数原型对象，而原型对象中包含一个constructor属性指向构造函数，因此在实例对象中可以通过原型链来访问到constructor属性，从而判断对象的类型。

优点：解决了工厂模式中对象类型无法识别的问题，并且创建自定义的构造函数意味着可以将它的实例标识为一种特定的类型。

缺点：在使用构造函数创建对象时，每个方法都会在实例对象中重新创建一遍，，会造成内存的浪费。

##### 3.原型模式

创建的每一个函数都有一个prototype属性，这个属性指向函数的原型对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法，通过使用原型对象可以让所有的对象实例共享它所包含的属性和方法，因此这样也解决了代码复用问题。

```js
function Person(){

}
Person.prototype.name = 'Tom'
Person.prototype.age = 15
Person.prototype.sayName = function(){
	console.log(this.name)
}
var person1 = new Person()
person1.sayName(); //Tom
var person2 = new Person()
person2.sayName(); //Tom
```

优点：解决了构造函数模式中多次创建相同方法的问题，所有的实例可以共享一组属性和方法。

缺点：省略了构造函数模式中传递参数的过程，所有实例默认都会取默认的属性值，不方便。

​			因为所有实例都是共享一组属性和方法，都是对同一引用类型进行操作，那么属性的操作就不是独立的，导致读写混乱。

##### 4.组合使用构造函数模式和原型模式

构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。好处是每个实例都会拥有自己的属性，但同时又共享着对方法的引用，最大限度节省了内存，而且还支持向构造函数传递参数，是及两种模式之长。

```js
function Person(name,age){
	this.name = name
	this.age = age
}
Person.prototype.sayName = function(){
    constructor: Person,
	console.log(this.name)
}
var person1 = new createPerson("james"，9，"student");
```

优点：采用了构造函数模式和原型模式的有点，是认可度最高的一种创建自定义类型的方法

缺点：由于使用了两种模式，对代码的封装性不是很好。

##### 5.动态原型模式

把所有信息都封装到构造函数里，而在构造函数中通过判断只初始化一次原型。

```js
function Person(name, age, job){
	this.name = name;    
	this.age = age;    
	this.job = job;    
	if(typeof this.sayName !== "function" ){        
		Person.prototype.sayName: function(){            
			alert(this.name);        
		}     
	}
}
var person1 = new createPerson("james"，9，"student");
```

 优点：解决了混成模式中封装性的问题 

# 11.js继承方式？

（1）组合继承

​	将原型链和构造函数组合到一块，发挥两者之长的一种继承模式。通过原型链实现对方法的继承，通过构造函数实现对实例属性的继承。

```js
function SuperType(name){
    this.name = name
    this.colors = ["red"]
}
SuperType.prototype.sayName = function(){
    console.log(this.name)
}
function SubType(age,name){
    //继承属性
    SuperType.call(this,name)
    this.age = age
}
//继承方法
SubType.prototype = new SuperType()
SubType.prototype.constructor = SubType

```

（2）寄生式组合继承

​	组合式继承的缺点是在子类的原型对象中添加了父类的实例对象的属性。

​	寄生式组合继承用来解决这个问题，它与组合式继承不同的地方是，在继承原型时，继承的不是父类的实例对象，而是继承原型对象是父类原型对象的一个实例对象。这样就解决了缺点的问题。

``` js
function Person(name) {
  this.name = name;
}
Person.prototype.sayName = function() {
  console.log("My name is " + this.name + ".");
};
function Student(name, grade) {
  Person.call(this, name);
  this.grade = grade;
}

Student.prototype = Object.create(Person.prototype); //新建一个以Person为原型对象的对象
Student.prototype.constructor = Student;

//方法重写
Student.prototype.sayMyGrade = function(a) {
    //方法重载
    if(typeof a === "number"){
        console.log("My grade is " + this.grade + "xxx");
    }else{
     	console.log("My grade is " + this.grade + "yyy");   
        
    }
  
};
```

联系：方法的重写和重载（多态的两个表现方式）

​	方法重写：和父类同名方法

​	方法重载：参数不同而结果不同



联系：原型链：

```
console.log(Object instanceof Function);
console.log(Function instanceof Object);
console.log(Function instanceof Function);
console.log(Object instanceof Object);
console.log(Function.prototype === Function.__proto__);
//都为true
```

# 13.谈谈对this,call,apply,bind的理解

this设计初衷是在函数内部使用，指代当前运行环境。函数可以在不同运行环境执行（如全局作用域，对象内），所以需要一个机制来表明代码在哪执行。

1.全局范围内的this

​	this等价于window对象；

​	用var声明一个变量和给this或者window添加属性是等价的；

​	如果在声明变量时候没有使用var,let,const，相当于在给全局this添加或者改变属性值。

``` js
//1
console.log(this === window) //true
//2
var name = "jack"
console.log(this.name) //jack
console.log(window.name)//jack
//3
age = 23
function testThis(){
    age = 18
}
console.log(this.age) //23
testThis()
console.log(this.age) //18
```

2.function中的this

​	this永远指向最后调用它的那个对象。

```js
var name = "windowsName";
function sayName() {
    var name = "Jake";
    console.log(this.name);   // windowsName
    console.log(this);    // Window
    console.log(name); // Jake
}
sayName();
console.log(this) // Window


function foo() {
    console.log( this.age );
}
var obj1 = {
    age : 23,
    foo: foo
};
var obj2 = {
    age : 18,
    obj1: obj1
};
obj2.obj1.foo(); // 23

```

3.构造函数中的this

​	当一个函数作为构造器使用时，this会指向新创建的实例上。如果没有使用new，就是一个普通函数，this指向window。

```js
var name = "Jake";jiuzhixiang
function testThis(){
  this.name = 'jakezhang';
  this.sayName = function () {
		return this.name;
	}
}
console.log(this.name ); // Jake

new testThis(); 
console.log(this.name ); // Jake

var result = new testThis();
console.log(result.name ); // jakezhang
console.log(result.sayName()); // jakezhang

testThis();  	//改变了window.name
console.log(this.name ); // jakezhang  

```

联系：

​	new的过程:

```js
var a = new Foo("jack")
//1.开辟空间，创建新对象obj
var obj = {}
//2.给新对象内部属性赋值，构造原型链
obj.__proto__ = Foo.prototype;
//3.执行函数Foo，执行过程中内部this指向新对象obj
var result = Foo.call(obj,"jack")
//4.如果Foo内部返回对象数据类型，则返回该对象，否则返回新对象obj
return typeof result === "Object" ? result : obj

```

4.class中的this

​	在es6中， 类通常包含一个 constructor ， this指向新创建的对象。类中的方法如果作为普通函数被调用，this可能指向其他值， 与方法一样，类也可能失去对接收器的跟踪。 

```js
class Hero {
  constructor(heroName) {
    this.heroName = heroName;
  }
  dialogue() {
    console.log(`I am ${this.heroName}`)
  }
}
const batman = new Hero("Batman");
batman.dialogue();

```

构造函数里的 this指向新创建的 类实例。当我们调用 batman.dialogue()时， dialogue()作为方法被调用， batman是它的接收器。

但是如果我们将 dialogue()方法的引用存储起来，并稍后将其作为函数调用，我们会丢失该方法的接收器，此时 this参数指向 undefined 。

```js
const say = batman.dialogue;
say();
```

出现错误的原因是JavaScript 类是隐式的运行在严格模式下的。我们是在没有任何自动绑定的情况下调用 say()函数的。要解决这个问题，我们需要手动使用 bind()将 dialogue()函数与 batman绑定在一起。

```js
const say = batman.dialogue.bind(batman);
say();
```

5.call,apply,bind中的this

​	三者称为this的强绑定，用来改变函数执行时的this指向。

```js
var name = "jack";
function foo(){
    console.log(this.name)
}
var obj = {
    name:"Tom"
}
foo(); //jack
foo.call(obj); // Tom
//等价于 foo.apply(obj)    foo.bind(obj)()
```

6.箭头函数中的this

​	es5中的this要看函数在什么地方调用，谁是最后调用此函数，来判断this指向。但ES6的箭头函数没有this绑定，必须查找作用域链来决定其值。如果箭头函数被非箭头函数包含，则this指向最近一层非箭头函数的this。否则this为undefined。箭头函数的this始终指向函数定义时的this，而非执行时。

```js
let name = "zjk";
let o = {
    name : "Jake",
    sayName: function () {
        console.log(this.name)     
    },
    func: function () {
        setTimeout( () => {
            this.sayName()
        },100);
    }

};
o.func()     // Jake

```

使用call，apply，bind方法给this传值，箭头函数会忽略。

```js
var number = 1;
var obj = {
    number:2,
    showNumber:function(){
        this.number = 3;
        (function(){
            console.log(this.number);
        })();
        console.log(this.number);
    }
};
obj.showNumber(); // 1  3
//showNumber()里的自调用function会提升到全局范围内，所以它的this是指向window对象
```

7.call,/apply和bind的区别

​	call/apply改变函数this上下文后马上执行该函数。返回函数执行结果

​	bind则是返回改变了this上下文的函数后，不执行函数。返回函数的拷贝，保存了函数的参数。

8.call/apply/bind的核心理念

​	向其他对象借用方法，A对象有个方法，B对象因为某种原因也需要用到这种方法，然后让B借用A的方法，既达到目的，又节省内存。

# 14.js原型，原型链？有什么特点？

​	在js中使用构造函数来创建对象，每个构造函数内部都有一个prototype属性，这个值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数创建一个对象后，在这个对象内部也包含一个指针，指向构造函数的prototype属性，这个指针被称为对象的原型。浏览器实现了proto属性来让我们访问这个属性，但是最好不要使用。可以用Object.getPrototype()来获取对象的原型。

​	当访问一个对象的属性时，如果不存在，那么它就会去原型对象中找，这个原型对象又有自己的原型，这样一直找下去，就是原型链的概念。原型链的尽头一般都是Object.prototype，所以这就是为什么新建的对象能够使用toString等方法的原因。

​	js对象是通过引用来传递的，我们创建的每个新对象中并没有属于自己的原型副本，当修改原型时，与之相关的对象也会继承这一改变。

# 15.什么是闭包，为什么要使用它？

1.闭包产生条件

​	函数嵌套

​	内部函数引用外部函数的局部变量

​	外部函数被调用了

​	（内部函数也要被调用或者引用，针对谷歌浏览器，在部分浏览器中有优化，内部函数不被调用或者引用相当于没有）

2.什么是闭包？

​	（包含被引用（外部函数）变量的对象）

​	闭包是一个引用关系，该引用关系存在于内部函数中，引用的是外部函数的变量，最终是一个对象。closure {c:undefined}

3.闭包作用

​	延长外部函数中变量的声明周期

​	让函数外部可以操作函数内部数据（间接修改内部变量）

注意：浏览器为了性能，后期将外部函数中不被内部函数使用变量清除了。

4.缺点

​	内存泄漏（内存释放不了）

​	导致内存溢出（内存被撑爆）

如果要用布包，记得把闭包清除。就是让定义的内部函数释放掉，去除对内部函数的引用 f =null



5.常见的闭包

​	1).将函数作为另一个函数的返回值

​	2).将函数作为实参传递给另一个函数

​	3).使用闭包实现私有方法操作独立的私有属性

6.题

```js
window.onload = function(){
    var btn = document.getElementById("btn");
    var n = 0;
    btn.onclick = function(){
        n++;
        console.log(n)
    }
}
//事件可以重复触发执行， 因为形成了闭包，变量无法释放，每次点击都是在之前的基础上++
//如果没有window.onload，变量则是全局变量。在window.onload里的变量，只是局部变量，不存在window属性中
```

```js
var name = "The Window";
var object = {
    name: "My Object",
    getNameFunc: function () {
        return function () {
            return this.name;
        };
    }
};
console.log(object.getNameFunc()()); //The Window
//存在闭包。
//最后返回的是一个普通函数，然后return this.name  指向的是window

```

```js
var name2 = "The Window";
var object2 = {
    name2: "My Object",
    getNameFunc: function () {
        var that = this;//如果说你想在内部其它函数当中使用外部函数的this，就把外部函数this保存起来
        return function () {
            return that.name2;
        };
    }
};
console.log(object2.getNameFunc()());//My Object
```

```js
function fun (n,o){
    console.log(o);
    return {
        fun: function(m){
            return fun(m,n)
        }
    }
}
var a = fun(0) //undefined
a.fun(1) //0
a.fun(2) //0
a.fun(3) //0

var b = fun(0).fun(1).fun(2).fun(3) // undefined, 0, 1, 2

var c = fun(0).fun(1) //undefined，0
c.fun(2); // 1
c.fun(3); // 1
```

![0O9(CE8(WC{0XTI_EP_WNPN](C:\Users\Administrator\Desktop\0O9(CE8(WC{0XTI_EP_WNPN.png)

***过程：

1.fun(0)执行，o不存在fun内部，则往上上找参数，存在参数o，则视为局部变量，结果为undefined。然后返回一个对象，赋值给a变量。

2.a.fun(1)执行，产生函数执行环境，传入参数m=1, 返回fun的函数调用，fun(1,n)，n不存在，则往上找，n使用了最外部函数的参数(局部变量)形成闭包，无法释放变量，所以找到外部fun的参数n=0，则调用的是fun(1,0)，继续产生函数执行环境，打印出此时o为0。然后返回一个对象，但是没有接收的对象，所以释放了。此时第二次执行函数fun的上下文环境也释放了。

3.a.fun(2)执行，传入参数m=2，返回fun的函数调用.fun(2,n)，往上找n，因为之前的函数执行环境都已经释放，所以此时n还是之前第一次形成闭包机制中无法释放的变量n=0。



4.fun(0)调用，打印o为undefined，返回一个对象，形成闭包机制，n变量值为0，无法释放；然后找个对象调用fun(1)，返回的是fun(1,n)，n找的是上面无法释放的n=0，所以，执行fun(1,0)，打印o = 0，n被赋值为1，返回一个新对象，此时又形成新的闭包机制；新对象继续调用fun(2)，返回的是fun(2,n)，此时n找的是新闭包机制上下文中的n=1，所以执行fun(2,1)，输出o=1。往后如此。。

```js
function Foo(){
	getName = function () { alert (1); };
	return this;
}
Foo.getName = function () { alert (2);};
Foo.prototype.getName = function () { alert (3);};
var getName = function () { alert (4);};
function getName() { alert (5);}

//预解析过程
function Foo(){
	getName = function () { alert (1); };
	return this;
}
//function getName() { alert (5);}
//var getName
Foo.getName = function () { alert (2);};
Foo.prototype.getName = function () { alert (3);};
getName = function () { alert (4);};

//输出
Foo.getName(); //2
getName(); //4
Foo().getName(); //1  Foo()修改了window.getName()
getName();//1

//new直到和后面如果组成表达式，就执行
new Foo.getName();//2
new Foo().getName();//3
new new Foo().getName();//3
```

7.闭包的使用

```js
(function(){
	var money = 100;
    function getMoney(){
        console.log(money)
    }
    window.getMoney = getMoney
})()
//让外部去使用内部变量，但是不会改变内部变量。
//jQuery就是这么做的。
```

# 16.DOM和BOM

​	1.DOM指的是文档对象模型，把文档当做一个对象来看，这个对象定义了处理网页内容的方法和接口。

DOM的根对象是document。

​	2.BOM指的是浏览器对象模型，把浏览器当做一个对象来看，这个对象定义了与浏览器进行交互的方法和接口。BOM的的核心对象window对象，包含属性document, screen ,location,history, navigator  等。window对象具有双重角色，既是js访问浏览器的一个接口，又是一个全局对象。在网页中定义的任何对象，变量，函数都作为全局对象的一个属性或者方法存在。

​	DOM的最根本的对象是BOM的window对象的属性。

# 17.三种事件模型

​	事件 是用户操作网页时发生的交互动作。

​	1.DOM0级模型（原始事件模型），这种模型不会传播，所以没有事件流的概念。监听函数也是元素的一个属性，通过指定属性来绑定，如btn.onclick，优点是所有浏览器都兼容，缺点是相同事件的监听只能绑定一个，后面会覆盖前面，无法通过事件冒泡，委托等机制完成更多事情。解绑事件可以btn.onclick = null。

​	2.IE事件模型，一次事件有两个过程，事件处理阶段和事件冒泡。首先执行目标元素绑定的监听事件，然后事件冒泡到document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。通过attachEvent来监听函数，可以添加多个， detachEvent 来解绑。缺点是只有IE浏览器才可以这么写。

​	3.DOM2级模型，此模型为W3C指定的标准模型。包含三个过程，

​		1).事件捕获，事件从document一直向下传播到目标元素，如果过程中经过的节点也有该事件，则执行。

​		2).事件处理，事件到达目标元素，执行事件函数

​		3).事件冒泡，事件从目标一直向上到document，依次检查执行。

submit事件不会被冒泡。

​		第一个参数为事件类型，第二个参数为处理函数，第三个参数用来指定是否在捕获阶段进行处理，一般用false。用 addEventListener 来绑定， removeEventListner 解绑

 stopPropagation（）方法 阻止冒泡

 IE 5.5: div -> body -> document 

 IE 6.0: div -> body -> html -> document 

 Mozilla 1.0: div -> body -> html -> document -> window  

# 18.事件委托

​	事件委托是利用浏览器事件冒泡的机制，因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数绑定到父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。

​	使用事件代理可以不必为每一个元素都绑定事件，减少了内存消耗，并且使用事件代理，可以实现事件的动态绑定，比如新增了一个子节点，不需要单独为它添加事件，都交给父节点来处理。

# 19.DOM操作-添加，移除，移动，复制，创建，查找节点

1.创建新节点

```js
createDocumentFragment() //创建一个DOM片段 
//创建的是一个虚拟的节点对象，不属于文档树，继承的parentNode属性总是null。它有一个很实用的特点，当请求把一个DocumentFragment节点插入文档树时，插入的不是DocumentFragment自身，而是它的所有子孙节点，即插入的是括号里的节点。当需要添加多个dom元素时，如果先将这些元素添加到DocumentFragment中，再统一将DocumentFragment添加到页面，会减少页面渲染dom的次数，效率会明显提升。

createElement() //创建一个具体的元素
createTextNode() //创建一个文本节点
```

2.添加，移出，替换，插入

```js
appendChild()
removeChild()
replaceChild(new,old)
insertBefore(new,old)
```

3.查找

```js
getElementById();
getElementsByName();
getElementsByTagName();
getElementsByClassName();
querySelector(); //返回匹配指定选择器的第一个元素
querySelectorAll(); //返回所有匹配元素
```

```js
var list = ul.getElementsByTagName('li');
for(var i =0;i<list.length;i++){
    ul.appendChild(document.createElement('li')); //动态追加li
}
//getXXXByXXX 获取的是动态集合，随着dom结构的变化而变化,当动态添加时，每一次调用list都会重新对文档进行查询，导致无限循环的问题

var list = ul.querySelectorAll('li');
for(var i = 0;i<list.length;i++){
    ul.appendChild(document.createElement('li'));//动态追加li
}
//querySelector获取的是静态集合。querySelectorAll('li')获取到ul里所有li后，不管后续再动态添加了多少li，都是不会对其参数影响。
```



4.属性操作

```js
getAttribute(key);
setAttribute(key, value);
hasAttribute(key);
removeAttribute(key);
```

# 20.js数组和字符串的原生方法

##### 1.数组方法：

​	push：末尾添加一个或多个元素，返回值为新的length。此方法改变了原数组。

```js
var arr = [1,2,3,4];
var res= arr.push(100,200,300);
console.log(res); //7
console.log(arr); //[1, 2, 3, 4, 100, 200, 300]
```

​	shift：删除数组中第一个元素，返回删除的元素。 此方法改变了原数组

```js
var arr = [1,2,3,4];
var res = arr.shift();
console.log(res); //1
console.log(arr); //[2, 3, 4]
```

​	unshift：在数组开头添加一个或多个元素，返回新的length。此方法改变了原数组

```js
var arr = [1,2,3,4];
var res = arr.unshift(11,22,33);
console.log(res); //7
console.log(arr); //[11, 22, 33, 1, 2, 3, 4]
```

​	pop：删除数组最后一个元素，返回删除的元素。此方法改变了原数组

```js
var arr = [1,2,3,4];
var res = arr.pop();
console.log(res); //4
console.log(arr); //[1, 2, 3]
```

​	splice：插入，删除，替换数组的元素。此方法改变了原数组

```js
//删除。
//参数1：开始位置   参数2：删除的个数
var arr = [1,2,3,4];
var res = arr.splice(1,2);
console.log(res) //[2,3] 返回删除的元素组成的数组
console.log(arr) //[1,4] 此方法改变了原数组

//插入
//参数1：开始位置  参数2：删除0个  参数n：新增元素
var arr = [1,2,3,4];
var res = arr.splice(1,0,22,33);
console.log(res) //[] 返回删除元素组成的数组 为空
console.log(arr) //[1,22,33,2,3,4]

//替换
//参数1：开始位置   参数2：删除n个  参数n:新增的元素
var arr = [1,2,3,4];
var res = arr.splice(1,2,55,66);
console.log(res) //[2,3] 返回删除元素组成的数组 为空
console.log(arr) //[1,55,66,4]
```

​	concat：连接两个或多个数组/在末尾拼接元素。不会改变原数组

```js
//拼接
var arr = [1,2,3,4]
var res = arr.concat(10,20)
console.log(res);// [1, 2, 3, 4, 10, 20]
var res2 = arr.concat([10,20],[55])
console.log(res2);// [1, 2, 3, 4, 10, 20，55]
console.log(arr); // [1,2,3,4] 不会改变原数组

//复制数组(浅拷贝)
var res = arr.concat();
console.log(res);//[1,2,3,4]
console.log(arr);//[1,2,3,4]
console.log(arr === res);// false
```

​	join：把数组转为字符串，通过指定分隔符分割。不会改变原数组

```js
var arr = ["大天使",0,"长米迦勒"]
var res = arr.join(); //默认
console.log(res) //大天使0长米迦勒
var res2 = arr.join("") //以逗号,连接
console.log(res2) //大天使，0，长米迦勒
console.log(arr)//["大天使",0,"长米迦勒"] 不会改变原数组
```

​	reverse：翻转数组，返回翻转后的新数组。改变原数组

```js
var arr = ["大天使",0,"长米迦勒"]
var res = arr.reverse();
console.log(res);//["长米迦勒",0,"大天使"]
console.log(arr);//["长米迦勒",0,"大天使"]  改变原数组
```

​	toString：将数组转化为字符串。不会改变原数组

```js
var arr = ["大天使",0,"长米迦勒"]
var res = arr.toString();
console.log(res);//大天使，0，长米迦勒
console.log(arr);//["大天使",0,"长米迦勒"]
```

​	slice：截取部分元素形成新数组。不会改变原数组

```js
var arr = [1,2,3,4]
var res = arr.slice(1,3);
console.log(res); //[2,3]
console.log(arr); // [1, 2, 3, 4] 不会改变原数组
```

​	sort：对数组进行排序。改变了原数组

``` js
var arr1 = [18,2,10,9,88,66];
var res1 = arr1.sort(); // [10, 18, 2, 66, 88, 9] 不写参数的话，把每个元素转为字符串按照Unicode码进行排序
var arr2 = [18,2,10,9,88,66];
var res2 = arr2.sort(function(a,b){
    return a-b; //升序。   降序为b-a
})
console.log(res2);//[2, 9, 10, 18, 66, 88]
console.log(arr2);//[2, 9, 10, 18, 66, 88] 改变了原数组
```

​	indexOf：返回目标元素在数组中的索引，没有找到返回-1

```js
var arr = [1,2,3,4];
var res = arr.indexOf(4) //第二个参数为开始检索的位置
console.log(res);//3
```

​	lastIndexOf：返回目标在数组中出现的最后一次索引，没找到返回-1

```js
var arr = [1,2,3,4,4,5];
var res = arr.lastIndexOf(4)
console.log(res);//4

```

​	forEach：遍历数组(效率比for高，但是不能使用break和continue)，参数是一个匿名函数，返回值为undefined

```js
var arr = [1,2,3,4];
var res = arr.forEach(function(val,index){
    console.log(val,index)
})
console.log(res) //undefined
```

​	map：对每个元素进行处理，遍历数组返回一个新数组，不会改变原数组

```js
var arr = [1,2,3,4];
var res = arr.map(function(val,index){
    return val*2
})
console.log(res) //[2,4,6,8]
console.log(arr) //[1,2,3,4]
```

​	filter：遍历过滤，返回的是符合return条件的元素组成的新数组

```js
var arr = [1,2,3,4];
var res = arr.filter(function(value,index){
return value>2;
})
console.log(res);//[3,4]
console.log(arr);//[1,2,3,4]
```

​	reduce: 对数组元素从左到右依次执行reducer函数，然后返回一个累计的值 

``` js
arr.reduce(function(prev,cur,index,arr){
    ...
},init)
//arr表示原数组，prev表示上一次调用回调时的返回值，或者是初始值，cur表示当前正在处理的元素，index表示当前正在处理的元素的索引，若提供init值，索引为0，否则为1，init表示初始值。

//运用
//求数组项之和
var sum = arr.reduce((prev,cur)=>{
    return prev + cur
},0)
//由于传入了初始值，所以开始时prev为0，cur为数组第一项，相加之后的返回值作为下一轮回调的prev值，然后继续与下一个数组项相加，直至完成所有数组项的和并返回

//求数组项最大值
var max = arr.reduce((prev,cur)=>{
    return Math.max(prev,cur)
})
//未传入初始值，开始prev为数组第一项，cur为第二项，取两者最大后继续进入下一轮回调。

//数组去重
var newArr = arr.reduce((prev,cur)=>{
    prev.indexOf(cur) === -1 && prev.push(cur)
    return prev
},[])
```

​	every：针对数组中的每一个元素进行比对，只要有一个元素比对结果为false则返回false，反之要所有的元素比对结果为true才为true 

```js
var a = [1,2,3,4,5,6];
var b = a.every(function(x){
    return x < 8;
});
console.log(b); //true
```

​	some：针对数组中的每一个元素，但是这个方法是，只要有一个元素比对结果为true，返回结果就为true，反之要所有的元素比对结果为false才为false

```js
var a = [1,2,3,4,5,6]
var b = a.some(function(x){
        return x > 10;
    })
var c = a.some(function(x){
        return x > 5;
    })
console.log(b) //这里返回false
console.log(c) //这里返回true
```

​	Array.from(ES6新增)：将一个类数组对象或者可遍历对象转化成一个真正的数组。

```js
let array = {
    0: 'name', 
    1: 'age',
    2: 'sex',
    3: ['user1','user2','user3'],
    'length': 4
}
let arr = Array.from(array)
console.log(arr) // ['name','age','sex',['user1','user2','user3']]
```

如果将上面对象中的length属性去掉，arr将会是一个长度为0的数组。

如果对象的属性名不是数字类型，则如下

``` js
let array = {
    'name': 'name', 
    'age': 'age',
    'sex': 'sex',
    'user': ['user1','user2','user3'],
    'length': 4
}
let arr = Array.from(array)
console.log(arr)  // [ undefined, undefined, undefined, undefined ]
```

如此可见：要将一个类数组对象转化为一个真正的数组，必须具备以下条件：

（1）类数组对象必须具有length属性，用于指定数组的长度，如果没有length属性，那么转换后的数组为一个空数组。

（2）类数组对象的属性名必须是数值，或者字符串型的数字。



Array.from还接受第二个参数，类似于数组map方法，用来对每个元素进行处理

```js
let arr = [1,2,3,4,5,6,7,8,9]
let set = new Set(arr)
console.log(Array.from(set, item => item + 1)) // [2,3,4,5,6,7,8,9,10]
```

将字符串转为数组

```js
let  str = 'hello world!';
console.log(Array.from(str)) // ["h", "e", "l", "l", "o", " ", "w", "o", "r", "l", "d", "!"]
```

##### 2.字符串的方法

​	字符串的方法，其实是字符串包装对象的方法。

​	字符串是一个基本值，以下所有方法都不会改变字符串原来的值。

​	charAt：找到索引下的字符

```js
var str = "123#@45456A我"
var res = str.charAt(1);
console.log(res); //2
```

​	charCodeAt：找到索引下的字符的Unicode码

```js
var str = "123#@45456A我"
var res = str.charCodeAt(1);
console.log(res);//50
```

​	concat：拼接字符串

```js
var str = "123#@45456A我"
var res = str.concat("哈哈哈");
console.log(res); //123#@45456A我哈哈哈
```

​	fromCharCode：把Unicode码转为字符

```js
var str = "123#@45456A我"
var res = String.fromCharCode(50);
console.log(res); //2
```

​	indexOf：找出指定字符串，返回索引，参数（要找的字符串，开始查找的位置），没找到返回-1

```js
var str = "123#@45456A我"
var res = str.indexOf("2",1);
console.log(res); //1
```

​	lastIndexOf：从右往左查找，返回的位置是从前面开始数的

```js
var str = "abcccdefg"
var res = str.lastIndexOf("c"); 
console.log(res); //4
```

​	slice：截取字符串，指定起始位置和长度

```js
var str = "123#@45456A我"
var res = str.substr(2,4)
console.log(res);//3#@4
```

​	substring：截取字符串，指定两个位置，不能为负数，会自动根据位置的大小决定起始和结束位置

```js
var str = "123#@45456A我"
var res = str.substring(2,4); //str.substring(4,2)
console.log(res); //3#
```

​	split：分割字符串，转化为数组

```js
var str = "123#@45456A我"
var res = str.split("");
console.log(res); //["1", "2", "3", "#", "@", "4", "5", "4", "5", "6", "A", "我"]
console.log(str.split()); //["123#@45456A我"]
console.log(str.split("A")); //["123#@45456", "我"]
console.log(str.split("你")); //["123#@45456A我"]
```

​	toLowerCase：转小写    toUpperCase：转大写   针对标准字符集GBK UTF-8

​	toLocalUpperCase：针对特殊字符集

​	

​	includes(ES6)：判断是否包含指定字符串

```js
var str = "dasdasd2113";
console.log(str.includes("sd2")); //true
```

​	startWith：判断是否以指定字符串开头

```js
var str = "dasdasd2113";
console.log(str.startsWith("d")); //true
```

​	repeat：指定重复次数

```js
var str = "dasdasd2113";
console.log(str.repeat(2)); //dasdasd2113dasdasd2113
```

# 21.Ajax是什么，如何创建一个Ajax

AJAX 全称为Asynchronous Javascript And XML，就是异步的Js和XML。通过Ajax可以在浏览器中向服务器发送异步请求，然后根据返回的数据，更新局部网页内容，而不用整个刷新页面的一种方法。

优点：可以无需刷新页面而与服务器进行通信，允许根据用户事件来更新部分网页内容。

缺点：没有浏览历史，不能回退。存在跨域问题。SEO不友好。

##### 1.原生Ajax

```js
//1.创建Ajax请求对象
let xhr = new XMLHttpRequest();
//2.绑定回调，处理服务器返回结果
xhr.onreadystatechange = function(){
    if(xhr.readyState === 4 && xhr.status === 200){
        console.log(xhr.responseText)
    }
}
//3.设置请求信息
xhr.open("GET","/") //第三个参数 true为异步，false为同步，默认为true
//4.发送
xhr.send();//get请求不传body参数，只有post请求使用
```

readyState状态说明：

​	0：未初始化， 此阶段确认XMLHttpRequest对象是否创建 。

​	1： 服务器连接已建立 ， 此阶段对XMLHttpRequest对象进行初始化，即调用open()方法 

​	2：请求已接收， 此阶段接收服务器端的响应数据 ，但获得的还只是服务端响应的原始数据，并不能直接在客户端使用。值为2表示已经接收完全部响应数据。 

​	3：请求处理中 ， 此阶段解析接收到的服务器端响应数据。即根据服务器端响应头部返回的MIME类型把数据转换成能通过responseBody、responseText或responseXML属性存取的格式，为在客户端调用作好准备。状态3表示正在解析数据。 

​	4： 请求已完成，且响应已就绪 。此阶段确认全部数据都已经解析为客户端可用的格式，解析已经完成。值为4表示数据解析完毕，可以通过XMLHttpRequest对象的相应属性取得数据。 

概括为： 创建－初始化请求－发送请求－接收数据－解析数据－完成 



状态响应码： https://www.cnblogs.com/zhangjianbin/p/6344063.html 



解决IE缓存问题：

​	在IE浏览器中由于缓存机制的存在，Ajax只会发送第一次请求，剩下的多次请求不会再发送而是直接加载缓存中的数据。

​	解决方式：浏览器的缓存是根据URL地址来记录的，修改URL来解决

​	xhr.open("get","/testAJAX?t="+Date.now());

##### 2.jQuery写法

```
$.ajax({
	type:"POST",
	url:"",
	async: true, //async异步 sync同步
	data:{a:100,b:200}, //针对post请求
	dataType:'json',  //服务器返回的数据类型（xml, html, script, json, text）
	contentType:"" //默认值:"application/x-www-form-urlencoded"。发送信息至服务器时内容编码类型。
	success:function (data) {

    },
    error:function (error) {

    }
})
```

##### 3.promise封装实现

```js
function promiseAjax(url){
    return new Promise((resolve,reject)=>{
        //1.创建Ajax对象
        let xhr = new XMLHttpRequest();
        //2.绑定监听
        xhr.onreadystatechange = function(){
            if(this.readyState !== 4) return;
            //当请求成功或失败时，改变promise状态
            if(x.status >= 200 && x.status < 300){
                resolve(this.response)
            }else{
                reject(new Error(this.statusText));
            }
        }
        //3.初始化
        xhr.open("GET", url, true);
        //4.发送
        xhr.send(null);
        //设置错误监听函数
        xhr.onerror = function(){
            reject(new Error(this.statusText));
        }
        // 设置响应的数据类型
        xhr.responseType = "json";

        // 设置请求头信息
        xhr.setRequestHeader("Accept", "application/json");
    })
}
```

# 22.js延迟记载的方式

​	js的加载解析和执行会阻塞页面的渲染过程，因此希望js延迟加载提高页面的渲染速度。

1.将js脚本放在文档底部，来使js尽可能在最后来加载执行。

2.给js添加  defer="defer" 属性，会让脚本的加载与文档的解析同步解析，然后在文档解析完成后执行这个脚本文件，能使页面的渲染不被阻塞。

3.给js脚本添加async属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行js，这个时候如果文档没有解析完成的话同样会阻塞。多个async属性的脚本执行顺序不可预测。

4.动态创建DOM标签的方式，对文档的加载事件进行监听，当文档加载完成后再动态创建script标签引入js

 https://blog.csdn.net/meijory/article/details/76389762 

# 23.模块化的理解

​	一个模块是实现一个特定功能的一组方法。

​	由于函数具有独立作用域的特点，最开始是使用函数作为模块，几个函数作为一个模块，但是这种方法容易造成全局变量的污染，并且模块之间没有联系。

​	后面提出对象写法，将函数作为一个对象的方法来实现，解决了直接使用函数作为模块的缺点，但是这种方法会暴露所有模块成员，外部代码可以修改内部属性值。

​	现在最常用的是立即执行函数的写法，利用闭包来实现模块私有作用域，避免了变量污染，同一模块内的成员也有了关系，在模块外部无法修改没有暴露出的变量和函数。

期望的模块系统：

​	模块的加载和传输，一种是每个模块都单独请求，另一种是所有模块打包成一个文件然后只请求一次。第一种方法造成请求次数过多，导致应用启动速度慢，第二种一次请求所有模块导致流量浪费，初始化过程慢。

​	分块传输，按需进行懒加载，在实际用到某些模块的时候再增量更新，才是较为合理的模块加载方式。要实现模块的按需加载，就需要一个对整个代码库中的模块进行静态分析，编译打包的过程。

​	提到的模块仅仅是指js文件，但是在开发过程中，样式，图片，字体等众多资源，如果都视作模块，并且都通过引入的方式进行加载，会有很好的体验。如何做到呢？就需要对整个代码进行静态分析，分析各个模块的关系，然后将不同模块提交给适配的加载器来处理，webpack就是在这种需求中应运而生的。

##### 模块系统

1.script

​	全局作用域下容易造成变量冲突

​	文件只能按照script顺序进行加载

​	开发人员必须主观解决模块和代码库的依赖关系

​	难以管理。

2.CommonJs

​	服务器端的node.js遵循commonjs规范，核心是允许模块通过require的方法来同步加载所依赖的其他模块，然后通过exports或者module.exports来导出暴露的接口。

​	优点：服务器端模块便于重用，简单并容易使用。

​	缺点：同步的模块加载不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的。不能非阻塞的并行加载多个模块。

3.AMD

 `define(id?, dependencies?, factory)`，它要在声明模块的时候指定所有的依赖 `dependencies`，并且还要当做形参传到 `factory` 中，对于依赖的模块提前执行，依赖前置。 

​	优点：适合在浏览器环境中异步加载模块，可以并行加载多个模块

​	缺点：代码的阅读和书写比较困难，模块定义方式的语义不顺畅。不符合通用的模块化思维。

4.CMD

​	优点：依赖就近，延迟执行，可以很容易在node中运行。

​	缺点：依赖SPM打包，模块的加载逻辑偏重。

5.ES6

​	ES6的设计思想，是尽量静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。commonjs和AMD，只能在运行时确定。

优点：容易进行静态分析。

缺点：新版的node支持。



​	requireJS是AMD规范的实现，SeaJS是CMD规范的实现，一个主张提前加载依赖，一个主张延迟加载依赖。后来出现了commonjs规范，webpack就是支持commonjs规范的。

​	commonjs是服务端规范，node就是采用这个规范，他是同步加载，毕竟服务端不用考虑异步。

### js的几种模块规范

​	1.commonjs方案，通过require来引入模块，通过module.exports导出接口，是服务器端的解决方案，是以同步的方式来引入模块，因为服务器文件都存储在本地磁盘，读取非常快，已同步的方式加载没有问题。但是如果在浏览器端，由于模块的加载是使用网络请求，所以使用异步加载的方式更加合适。

​	2.AMD，采用异步加载的方式，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等加载完后再执行回调。requireJS实现了AMD规范。

​	3.CMD，也是异步加载的方式。SeaJS实现了CMD规范，和require.js的区别在于模块定义时对依赖的处理不同，和堆依赖模块执行时机的处理不同。

​	4.ES6，使用import和export的形式来导入导出模块。

区别：

 1.AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。 

2.第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于 模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句 的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。

```js
// CMD
define(function(require, exports, module) {
  var a = require("./a");
  a.doSomething();
  // 此处略去 100 行
  var b = require("./b"); // 依赖可以就近书写
  b.doSomething();
  // ...
});

// AMD 默认推荐
define(["./a", "./b"], function(a, b) {
  // 依赖必须一开始就写好
  a.doSomething();
  // 此处略去 100 行
  b.doSomething();
  // ...
});
```

# 24.js运行机制

#### 1.js单线程

​	js语言的一大特点就是单线程，即同一时间只能做一件事。

作为浏览器脚本语言，js的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，都这会带来很多复杂的同步问题。比如，假定有两个线程，一个线程在某个节点上添加内容，另一个线程删除了这个节点，这时该以哪个线程为准？所以为了避免复杂性，就是单线程。

#### 2.js事件循环

​	js代码执行过程的任务分为两类：同步和异步。

当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染，而像加载图片音乐之类占用资源大，耗时久的任务，就是异步任务。

过程：

​	同步和异步任务分别进入不同的执行“场所”，同步的进入主线程，异步的进入事件列表并注册函数。

​	当指定的事情完成时，事件列表会将整个函数移入事件队列。

​	主线程的任务执行完毕为空时，会去事件队列读取对应函数，进入主线程执行。

​	上述过程不断重复，就是event loop事件循环。

js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就去事件队列检查是否有等待被调用的函数。

```js
let data = [];
$.ajax({
    url:www.javascript.com,
    data:data,
    success:() => {
        console.log('发送成功!');
    }
})
console.log('代码执行结束');
/*
	ajax进入事件列表，注册回调函数success
	执行console.log("代码执行结束")
	ajax事件完成，回调函数success进入事件队列
	主线程从事件队列读取回调函数success
*/

```

#### 3.setTimeout和 setInterval

```js
setTimeout(()=>{
	task()
},3000)
sleep(100000000000)
```

执行task()需要的时间远远超过3秒，

task()进入事件列表并注册，计时开始。

执行sleep函数，很慢，计时仍在继续。

3秒到了timeout完成，task()进入事件队列，但是sleep还没有执行完，只好等着。

等sleep执行完，task从事件队列进入主线程执行。



setInterval会每隔指定的时间将注册的函数置入时间队列，如果同步任务耗时太久，依然会等待。

#### 4.Promise和process.nextTick(callback)

process.nextTick(callback)类似node版的settimeout，在事件循环的下一次循环中调用callback回调函数。

macro-task宏任务： 包括整体代码script，setTimeout，setInterval

micro-task微任务：promise，process.nextTick

```js
setTimeout(function() {
    console.log('setTimeout');
})

new Promise(function(resolve) {
    console.log('promise');
}).then(function() {
    console.log('then');
})

console.log('console');

```

这段代码作为宏任务，进入主线程。

先遇到setTimeout，那么将回调函数注册并分发到宏任务队列。

接下来遇到Promise，new Promise立即执行，then函数分发到微任务队列。

遇到console.log()立即执行。

整体代码script作为第一个宏任务执行结束，看看有哪些微任务，发现then在微任务里，执行。

第一轮事件循环结束，开始第二轮，从宏任务队列开始，发现有setTimeout对应的回调函数，执行。



##### 每一轮事件循环：

![img](https://user-gold-cdn.xitu.io/2017/11/21/15fdcea13361a1ec?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 

一波宏任务执行完后，看看有没有可执行的微任务，如果有，就走微任务，走完就算一轮。

代码例子：

```js
console.log('1');

setTimeout(function() {
    console.log('2');
    process.nextTick(function() {
        console.log('3');
    })
    new Promise(function(resolve) {
        console.log('4');
        resolve();
    }).then(function() {
        console.log('5')
    })
})
process.nextTick(function() {
    console.log('6');
})
new Promise(function(resolve) {
    console.log('7');
    resolve();
}).then(function() {
    console.log('8')
})

setTimeout(function() {
    console.log('9');
    process.nextTick(function() {
        console.log('10');
    })
    new Promise(function(resolve) {
        console.log('11');
        resolve();
    }).then(function() {
        console.log('12')
    })
})

```

第一轮事件循环流程分析如下：

- 整体script作为第一个宏任务进入主线程，遇到`console.log`，输出1。
- 遇到`setTimeout`，其回调函数被分发到宏任务Event Queue中。我们暂且记为`setTimeout1`。
- 遇到`process.nextTick()`，其回调函数被分发到微任务Event Queue中。我们记为`process1`。
- 遇到`Promise`，`new Promise`直接执行，输出7。`then`被分发到微任务Event Queue中。我们记为`then1`。
- 又遇到了`setTimeout`，其回调函数被分发到宏任务Event Queue中，我们记为`setTimeout2`。

| 宏任务Event Queue | 微任务Event Queue |
| :---------------: | :---------------: |
|    setTimeout1    |     process1      |
|    setTimeout2    |       then1       |

- 上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。
- 我们发现了`process1`和`then1`两个微任务。
- 执行`process1`,输出6。
- 执行`then1`，输出8。

好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从`setTimeout1`宏任务开始：

- 首先输出2。接下来遇到了`process.nextTick()`，同样将其分发到微任务Event Queue中，记为`process2`。`new Promise`立即执行输出4，`then`也分发到微任务Event Queue中，记为`then2`。

| 宏任务Event Queue | 微任务Event Queue |
| :---------------: | :---------------: |
|    setTimeout2    |     process2      |
|                   |       then2       |

- 第二轮事件循环宏任务结束，我们发现有`process2`和`then2`两个微任务可以执行。
- 输出3。
- 输出5。
- 第二轮事件循环结束，第二轮输出2，4，3，5。
- 第三轮事件循环开始，此时只剩setTimeout2了，执行。
- 直接输出9。
- 将`process.nextTick()`分发到微任务Event Queue中。记为`process3`。
- 直接执行`new Promise`，输出11。
- 将`then`分发到微任务Event Queue中，记为`then3`。

| 宏任务Event Queue | 微任务Event Queue |
| :---------------: | :---------------: |
|                   |     process3      |
|                   |       then3       |

- 第三轮事件循环宏任务执行结束，执行两个微任务`process3`和`then3`。
- 输出10。
- 输出12。
- 第三轮事件循环结束，第三轮输出9，11，10，12。

整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。

process.nextTick指定的异步任务总是发生在所有异步任务之前，也就是说微任务中先执行process.nextTick

##### 重要：js是一门单线程语言，无论什么实现所谓的异步，都是用同步的方法去模拟的。事件循环是js实现异步的一种方法，也是js的执行机制。

# 25.arguments的对象是什么

arguments对象是函数中传递的参数值的集合。它是一个类数组对象，因为有length属性，可以使用索引来访问单个值，但是没有数组内置方法。

 可以使用Array.prototype.slice将arguments对象转换成一个数组。 

```js
function one() {
  return Array.prototype.slice.call(arguments);
}
/*
	理解第一步:  其中，arguments是一个具有length属性的对象, 通过call 这个方法，把arguments 指向了Array.prototype.slice方法的作用域，也就是说通过call方法，让Array.prototype.slice对arguments对象进行操作
	理解第二步:  Array.prototype.slice就是对该对象使用Array类的slice方法。但是呢arguments它又不是个Array对象
*/
```

箭头函数没有arguments对象

```js
function one() {
	console.log(arguments); //Arguments [callee: ƒ, Symbol(Symbol.iterator): ƒ]
}
one()

const four = () => arguments;
four(); // arguments is not defined

//使用rest语法，可以解决这个问题,会自动将所有参数值放入数组中。
const four = (...args) => {
    console.log(args); //[]
};
four()
```

# 26.垃圾回收机制

程序是运行在内存里的，当声明变量，定义函数等都会占用内存。内存的容量有限，所以，当某个变量或对象在未来的程序中不会被访问，向这些对象要求归还内存。

垃圾回收方法：

###### 	1.引用计数：当被引用的个数变为1，就会被垃圾回收

```js
let obj1 = { a: 1 }; // 一个对象（称之为 A）被创建，赋值给 obj1，A 的引用个数为 1 
let obj2 = obj1; // A 的引用个数变为 2

obj1 = 0; // A 的引用个数变为 1
obj2 = 0; // A 的引用个数变为 0，此时对象 A 就可以被垃圾回收了
```

```js
function func() {
    let obj1 = {};
    let obj2 = {};

    obj1.a = obj2; // obj1 引用 obj2
    obj2.a = obj1; // obj2 引用 obj1
}
```

当函数执行结束后，返回值为undefined，整个函数和内部变量应该被回收，但是根据引用计数法，引用次数都不为0，所以不会被回收。要解决，最好在不用他们的时候设置为null

###### 	2.标记-清除和标记-整理

​	JavaScript 中有个全局对象，浏览器中是 window。定期的，垃圾回收期将从这个全局对象开始，找所有从这个全局对象开始引用的对象，再找这些对象引用的对象...对这些活着的对象进行标记，这是标记阶段。清除阶段就是清除那些没有被标记的对象。标记－清除法的一个问题就是不那么有效率，因为在标记－清除阶段，整个程序将会等待，所以如果程序出现卡顿的情况，那有可能是收集垃圾的过程。

 	标记清除有一个问题，就是在清除之后，内存空间是不连续的，即出现了内存碎片。如果后面需要一个比较大的连续的内存空间时，那将不能满足要求。而标记-整理方法可以有效地解决这个问题。标记阶段没有什么不同，只是标记结束后，标记-整理方法会将活着的对象向内存的一边移动，最后清理掉边界的内存。不过这种做法的效率没有标记-清除高。 

​	V8引擎垃圾回收机制。（看书签）

# 27.哪些操作会造成内存泄漏

1.意外的全局变量。

```js
//在函数中的变量，没有声明。或者使用this创建的变量
function fn () {
	a = "Actually, I'm a global variable"
}
```

2.被遗忘的计时器或回调函数

3.脱离DOM的引用（如对象的属性值为DOM元素）

4.闭包

###### 如何避免内存泄漏：

​	注意程序逻辑，避免死循环

​	减少不必要的全局变量，或者生命周期较长的对象，以及无用的数据进行垃圾回收

​	避免创建过多的对象

# 28.ES6新特性

块级作用域

类

箭头函数

模板字符串

加强的对象字面

对象解构

promise

模块

symbol

代理（proxy）Set

函数默认参数

rest和展开

# 29.var，let，const的区别

1.var声明的变量会挂载到window上。

2.var声明变量存在变量提升，let和const不存在

```js
console.log(a); // undefined  ===>  a已声明还没赋值，默认得到undefined值 
var a = 100; 
console.log(b); // 报错：b is not defined  ===> 找不到b这个变量 
let b = 10;
```

3.let和const形成块级作用域

```js
if(1){
  var a = 100;
  let b = 10;
  const c = 1;
}
console.log(a); // 100
console.log(b)  // 报错：b is not defined  ===> 找不到b这个变量
console.log(c)  // 报错：c is not defined  ===> 找不到c这个变量
```

4.同一作用域下let和const不能声明同名变量，var可以

5.暂存死区

```js
let a = 2//Uncaught ReferenceError：a is not defined
///// 以上区域则为暂存死区
console.log(a);
```

6.const一旦声明就必须赋值，否则报错Missing initializer in const declaration

​			声明后不能修改

​			如果声明的是复合类型数据，可以修改其属性	

```js
const list = [];
list[0] = 10;
console.log(list);　　// [10]
```

# 30.什么是类

类class是js中编写构造函数的新方法。它是使用构造函数的语法糖，在底层使用的依然是原型和基于原型的继承。

```js
//ES5 Version
function Person(firstName, lastName, age, address){
    this.firstName = firstName;
    this.lastName = lastName;
    this.age = age;
    this.address = address;
}

Person.self = function(){
    return this;
}

Person.prototype.toString = function(){
    return "[object Person]";
}

Person.prototype.getFullName = function (){
    return this.firstName + " " + this.lastName;
}  
//ES6 Version
class Person {
    constructor(firstName, lastName, age, address){
        this.lastName = lastName;
        this.firstName = firstName;
        this.age = age;
        this.address = address;
    }

    static self() {
        return this;
    }

    toString(){
        return "[object Person]";
    }

    getFullName(){
        return `${this.firstName} ${this.lastName}`;
    }
}
```

重写方法并从另一个类继承。

```js
//ES5 version
Employee.prototype = Object.create(Person.prototype)
function Employee(firstName, lastName, age, address, jobTitle, yearStarted){
    Person.call(this,firstName, lastName, age, address)
    this.jobTitle = jobTitle;
  	this.yearStarted = yearStarted;
}
Employee.prototype.describe = function () {
  return `I am ${this.getFullName()} and I have a position of ${this.jobTitle} and I started at ${this.yearStarted}`;
}

Employee.prototype.toString = function () {
  return "[object Employee]";
}

//ES6 version
class Employee extends Person{
    constructor(firstName, lastName, age, address, jobTitle, yearStarted){
        super(firstName, lastName, age, address);
        this.jobTitle = jobTitle;
        this.yearStarted = yearStarted;
    }
    describe() {
        return `I am ${this.getFullName()} and I have a position of ${this.jobTitle} and I started at ${this.yearStarted}`;
    }

    toString() { // Overriding the "toString" method of "Person"
        return "[object Employee]";
    }
}
```

# 31.模板字符串

在ES5版本中，需要在字符串中添加\n来添加新行，在ES6中直接以反引号``包裹回车就行。

在ES5版本中，需要添加表达式和值，需要使用+拼接，ES6中使用${}来嵌入。

# 32.对象解构

```js
const employee = {
  firstName: "Marko",
  lastName: "Polo",
  position: "Software Developer",
  yearHired: 2017
};
//解构语法
let { firstName, lastName, position, yearHired } = employee;
//为属性取别名
let { firstName: fName, lastName: lName, position, yearHired } = employee;
//设置默认值
let { firstName = "Mark", lastName: lName, position, yearHired } = employee;
```

# 33.Set对象

​	Set对象允许存储任何类型的唯一值，无论是原始值还是对象引用。 

```js
//使用Set构造函数创建Set实例
const set1 = new Set();
const set2 = new Set(["a","b","c","d","d","e"]);

//可以使用add方法向Set实例中添加一个新值，因为add方法返回Set对象，所以我们可以以链式方法，如果已经存在于Set对象中，将不再添加。
set2.add("g").add("h").add("i").add("j").add("k").add("k");//最后一个k不会被添加

//使用has检查Set实例里是否存在某个值
set2.has("a") // true

//获得长度
set2.size // returns 10

//clear删除数据
set2.clear();
```

使用Set对象删除数组中重复的元素

```js
const numbers = [1, 2, 3, 4, 5, 6, 6, 7, 8, 8, 5];
const uniqueNums = [...new Set(numbers)] //[1,2,3,4,5,6,7,8]
```

另外还有WeakSet，与Set类似，也是不重复的值的集合，但是WeakSet的成员只能是对象。

WeakSet中的对象都是弱引用。

​	关于弱引用和强引用：如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题；弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

##### Map数据结构

​	类似于对象，也是键值对的集合，但是键的范围不仅限于字符串，各种类型的值都可以当做键。

WeakMap的结构与Map类似，但是只接受对象作为键名（null除外），不接受其他类型的值作为键名。而且WeakMap的键名所指向的对象，不计入垃圾回收机制。

# 34.Proxy

```javascript
let p = new Proxy(target, handler); //target可以是普通对象，数组，函数，proxy实例对象
```

主要是通过handler对象中的拦截方法拦截目标对象target的 

# 35.通用的事件侦听器函数

```js
const EventUtils = {
  // 视能力分别使用dom0||dom2||IE方式 来绑定事件
  // 添加事件
  addEvent: function(element, type, handler) {
    if (element.addEventListener) {
      element.addEventListener(type, handler, false);
    } else if (element.attachEvent) {
      element.attachEvent("on" + type, handler);
    } else {
      element["on" + type] = handler;
    }
  },

  // 移除事件
  removeEvent: function(element, type, handler) {
    if (element.removeEventListener) {
      element.removeEventListener(type, handler, false);
    } else if (element.detachEvent) {
      element.detachEvent("on" + type, handler);
    } else {
      element["on" + type] = null;
    }
  },

  // 获取事件目标
  getTarget: function(event) {
    return event.target || event.srcElement;
  },

  // 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event
  getEvent: function(event) {
    return event || window.event;
  },

  // 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）
  stopPropagation: function(event) {
    if (event.stopPropagation) {
      event.stopPropagation();
    } else {
      event.cancelBubble = true;
    }
  },

  // 取消事件的默认行为
  preventDefault: function(event) {
    if (event.preventDefault) {
      event.preventDefault();
    } else {
      event.returnValue = false;
    }
  }
};
```

# 36.函数式编程

​	函数式编程（FP，functional programming）是通过编写纯函数，避免共享状态、可变数据、副作用来构建软件的过程。函数式编程是一种编程范式。

##### 1.纯函数

​	1）给定相同的参数，则返回相同的结果（也称为确定性）

​	2）不依赖（包含）任何外部变量，所以也不会产生改变外部环境变量的副作用。 

任何依赖于随机数生成器的函数都不能是纯函数。

# 37.什么是高阶函数

高阶函数（HOC，higher order function）：

​	接受函数作为参数

​	返回函数作为输出，

​	接受函数作为参数且返回函数作为参数，

满足之一就是高阶函数

# 38.为什么函数被称为一等公民

​	在js中，函数不仅拥有一切传统函数的使用方式，声明和调用，也可以做到像简单值一样，

赋值给变量： var func = function(){} 

作为参数传递给其他函数： function func(x,callback){callback();} 

作为其他函数的返回结果： function(){return function(){}} 

不仅如此，函数还可以充当类的构造函数，同时又是一个Function类的实例。

这样的多重身份让js函数变得非常重要。

# 39.手写Array.pototype.map,filter,reduce方法

map()创建一个新数组，其结果是原数组中的每个元素都调用一个提供的函数后返回的结果。

```js
function map(arr, mapCallback) {
  // 检查传递的参数是否正确。
  if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== 'function') { 
    return [];
  } else {
    let result = [];
    // 创建新数组，因为不能改变原始数组。
    for (let i = 0, len = arr.length; i < len; i++) {
      result.push(mapCallback(arr[i], i, arr)); 
      // 将 mapCallback 返回的结果 push 到 result 数组中
    }
    return result;
  }
}
```

filter()方法返回一个新数组，包含通过筛选的所有元素。

```js
function filter(arr,callback){
    //检查参数是否正确
    if(!Array.isArray(arr) || !arr.length || typeof callback !== "function"){
        return[]
    }else{
        let res = [];
        for(let i = 0; len = arr.lengthl i < len; i++){
            if(callback(arr[i],i,arr)){
                res.push(arr[i])
            }
        }
        return res;
    }
}
```

reduce()方法对数组中每个元素执行一个提供的reducer函数，讲其结果汇总为单个返回值

```js
function reduce(arr,callback,initValue){
    //检查参数是否正确
    if(!Array.isArray(arr) || !arr.length || typeof callback !== "function"){
        return[]
    }else{
        //如果没有初始值，将数组第一项作为初始值
        let hasInitValue = initValue !== undefined
        let value = hasInitValue ? initValue : arr[0]
        //如果有初始值，索引从1开始，否则从0开始
        for(let i = hasInitValue ? 1:0, len = arr.length; i < len; i++){
            value = callback(value,arr[i],arr)
        }
        return value
    }
}
```

# 40.for in，Object.keys和Object.getOwnPropertyNames的区别

联系：什么是枚举？

​	可枚举可以理解为是否可以被遍历列举出来，可枚举属性决定了这个属性是否能被for in查找遍历到。

​	js基本包装类型的原型属性是不可枚举的。

注意：并不是所有属性都会在for in循环中显示，数组的length属性和constructor属性不会被显示。

Object.propertylsEnumerable()可以判断属性是否可枚举，通过原型链继承的属性除外，如果对象不具有自定义的属性，则返回false

```js 
//例一
var obj = {} 
obj.propertyIsEnumerable('a') //false 
//例二
var obj = {a：1} 
obj.propertyIsEnumerable('a') //true
```

开始正题

```js
var parent = Object.create(Object.prototype, {
    a: {
        value: 1,
        writable: true,
        enumerable: true,
        configurable: true            
    }
});
//Object.create 新增的参数a添加在原型下。
```

parent继承自Object.prototype，有一个可枚举属性a。再创建一个继承parent的对象child

```js
var child = Object.create(parent, {
    b: {
        value: 2,
        writable: true,
        enumerable: true,
        configurable: true
    },
    c: {
        value: 3,
        writable: true,
        enumerable: false,
        configurable: true
    }
});
```

 child有两个属性b和c，其中b为可枚举属性，c为不可枚举属性。 

下面用各种方法来遍历child对象，比较它们的不同。

#### 1.for in

```js
for (var key in child) {
    console.log(key);
}
//b 
//a
```

for in会输出自身以及原型链上可枚举的属性。

如果仅想输出自身属性，可以使用hasOwnProperty，可以过滤掉原型链上的属性。

```js
for (var key in child) {
    if (child.hasOwnProperty(key)) {
        console.log(key);
    }
}
// b
```

#### 2.Object.keys

用来获取对象自身可枚举的属性键。

```js
console.log(Object.keys(child));
//  ["b"]
```

效果和 for in+hasOwnProperty的效果是一样的。 

#### 3.Object.getOwnPropertyNames

用来获取对象自身的全部属性名

```js
console.log(Object.getOwnPropertyNames(child));
// > ["b", "c"]
```

无论是否可枚举都可以拿到。

# 41.深拷贝和浅拷贝

都是针对的引用类型，对值类型进行赋值会对值进行一份拷贝，而对引用类型赋值，会进行地址的拷贝，最终两个变量指向同一地址。

```js
//基本类型
var a = 1;
var b = a;
a = 2;
console.log(a,b) // 2,1

//引用类型
var a = {c:1};
var b = a;
a.c = 2;
cosole.log(a.c,b.c) //2,2
```

如何切断a和b直接的关系呢，可以拷贝一份a的数据，根据拷贝的层级不同可以分为浅拷贝和深拷贝，浅拷贝就是只进行一层拷贝，深拷贝是无限层拷贝。

浅拷贝例如：

```js
function shallowClone(source){
    var target = {};
    for(var i in source){
        if(source.hasOwnProperty(i)){
            target[i] = source[i]
        }
    }
    return target
}
```

#### 最简单的深拷贝

深拷贝的问题可以分解为，浅拷贝 + 递归。

```js
//假如有var a1 = {b:  {c: {d: 1} } }

function clone(source){
	var target = {};
    for(var i in source){
        if(source.hasOwnProperty(i)){
            if(typeof source[i] === "object"){
                target[i] = clone(source[i])
            }else{
                target[i] = source[i]
            }
        }
    }
    return target
}
```

上面的代码，没有对参数做检验；判断是否为对象的逻辑不严谨，没有考虑数组的兼容

```js
//判断对象
function isObject(x){
    return Object.prototype.toString.call(x) === '[object Object]'
}
```

检验参数，不是对象的话直接返回

```js
function clone(source){
    if(!isObject(source)) return source
}
```

递归的最大问题在于爆栈，当数据的层次很深时就会栈溢出

```js
//指定深度和每层广度
function createDate(deep,breadth){
    var data = {};
    var temp = data;
    for(var i = 0; i < deep; i++){
        temp = temp['data'] = {};
        for(var j = 0; j < breadth; j++){
            temp[j] = j
        }
    }
    return data
}
createData(1,3) //1层深度，每层有3个数据 {data: {0:0,1:1,2:2}}
createData(3,0) //层深度，每层有3个数据 {data: {data: {data: {} } } }
```

当clone层级很深的话就会栈溢出，但是数据的广度不会造成溢出

```js
clone(createData(1000)); //ok
clone(createData(10000)); //Maximum call stack size exceeded

clone(createData(10,10000))// ok 广度不会溢出
```

大部分情况下不会出现深层级的数据，但这种方式有一个致命问题，就是循环引用

关于循环引用的问题解决思路由两种，一种是循环检测，一种是暴力破解，暴力破解下面会介绍。

##### 联系：

循环引用的对象使用 JSON.stringify 会报错，无法将一个无限引用的对象序列化为JSON字符串。

 一个JSON扩展包做到了这一点， 使用 JSON.decycle 可以去除循环引用。



#### 一行代码的深拷贝

```js
function cloneJSON(source){
    return JSON.parse(JSON.stringify(source))
}
```

```js
cloneJSON(createData(10000))//Maximum call stack size exceeded
```

层数过多还是会溢出，可知cloneJSON内部也是使用递归方式

但是不会因为死循环而导致栈溢出。因为JSON.stringify内部做了循环引用检测。

```js
var a = {};
a.a = a
cloneJSON(a) //Convering circular structure to JSON
```

#### 破解递归爆栈

有两种方法，消除尾递归，和不用递归而改用循环。

具体代码： https://segmentfault.com/a/1190000016672263 

改为循环后，就不会出现爆栈问题，但是对循环引用依然无力应对



#### 可以使用的深拷贝代码：

```js
function deepCopy(source){
    if(typeof source !=='object')return source;
    let target = Array.isArray(source)?[]:{};
    for(let i in source){
        if(source.hasOwnProperty(i)){
            if(typeof  source[i]==='object'){
               target[i]= deepCopy(source[i]);
            }else{
                target[i]=source[i];
            }
        }
    }
    return target;
}
```

# 42.深浅拷贝2

​	浅拷贝：创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，如果其中一个对象改变了地址，就会影响到另一个对象。

​	深拷贝：将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域来存放新对象，且修改新对象不会影响原对象。

##### 最简单版（深拷贝）：

​	JSON.parse(JSON.stringify(obj))

​	将对象序列化再反序列化，但是有下面几个坑： （https://www.jianshu.com/p/b084dfaad501 ）

​	1.如果obj里有时间对象，拷贝之后，时间将只是字符串的形式，而不是时间对象。

​	2.如果obj里有RegExp、Error对象，拷贝后得到的是空对象。

​	3.如果obj里有函数，undefined，则拷贝结果会丢失包含函数和undefined的属性。

​	4.如果obj里有 NaN、Infinity和-Infinity，则拷贝结果会变为null。

​	5.JSON.stringify()只能序列化对象的可枚举的自有属性，如果obj中某个属性值为对象，该对象是由别的构造函数生成的，那么拷贝后会丢弃对象的constructor。

​	6.如果对象中存在循环引用的情况也无法正确实现深拷贝。

##### 基础版：

简单浅拷贝：

```js
//创建一个新对象，遍历需要拷贝的对象，将属性依次添加到新对象上。
function clone(target){
    let cloneTarget ={};
    for(const key in target){
        cloneTarget[key] = target[key]
    }
    return cloneTarget
}
```

如果拷贝的对象是很多层的，那么可以用递归，直到属性为原始类型。

简单深拷贝：

```js
function clone(target){
    if(typeof targrt === "Object"){
        let cloneTarget = {};
        for (const key in target){
            cloneTarget[key] = clone(target[key])
        }
        return cloneTarget
    }else{
        return target
    }
}
```

还有很多缺陷，没有考虑数组。

##### 兼容数组

```js
function clone(target){
    if(typeof target === "object"){
        let cloneTarget = Array.isArray(target)?[]:{}
        	for(const key in target){
                cloneTarget[key] = clone(target[key])
            }
        return cloneTarget
    }else{
        return target
    }
}
```

##### 循环引用

执行如下测试用例：

```js
const target = {
    field1: 1,
    field2: undefined,
    field3: {
        child: 'child'
    },
    field4: [2, 4, 8]
};
target.target = target;
```

会因为递归进入死循环而导致栈内存溢出，原因就是上面的对象存在循环引用的情况，即对象的属性间接或直接引用了自身。

解决循环引用问题，可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去这个存储空间找有没有拷贝过这个对象，如果有就直接返回，如果没有就继续拷贝。

这个存储空间，需要可以存储key-value形式的数据，且key可以是一个引用类型，可以选择Map这种数据结构：

1.检查map中有无克隆过的对象；2.有则直接返回；3.没有，将当前对象作为key，克隆对象作为value进行存储。

4.继续克隆。

```js
function clone(target,map = new Map()){
    if(typeof target === "object"){
        let cloneTarget = Array.isArray(target)?[]:{}
        if(map.get(target)){
            return target
        }
        map.set(target,cloneTarget);
        for(const key in target){
            cloneTarget[key] = clone(target[key],map);
        }
        return cloneTarget
    }else{
        return target
    }
}
```

执行不会报错，且target属性，变为一个Circular类型，即循环引用的意思。

##### 使用WeakMap来代替Map

​	WeakMap对象是一组键值对的集合，其中的键都是弱引用，且键必须是对象，而值可以是任意的。

如果拷贝的对象非常庞大，使用Map会对内存造成很大的消耗，我们需要手动清除Map属性才能释放，而WeakMap会化解这个问题。

##### 性能优化

​	在上面，遍历使用了for in这种方式，实际上for，while，forin的执行效率，while效率是最好的。

先使用while实现一个通用的myforEach遍历，iterate是遍历的回调函数，可以接受每次遍历的value和index两个参数。

```js
function myforEach(arr,iterate){
    let index = -1;
    const length = arr.length;
    while(++index < length){
        iterate(arr[index],index);
    }
    return arr
}
```

对clone进行改写，当遍历数组时，用myforEach进行遍历，当遍历对象时，使用Object.keys取出所有的key进行遍历，然后遍历时把key作为回调函数里的value使用。

```js
function clone(target,map = new WeakMap()){
    //参数是否为对象
    if(typeof target === "object"){
        //是否为数组
        const isArray = Array.isArray(target);
       	//给cloneTarget赋值为对象或者数组
        let cloneTarget = isArray ? []; {}
        //map里如果已经存在过该对象，那么直接返回
        if(map.get(target)){
            return target
        }
        //map里如果没有存在过该对象，那么将该对象作为key，
        map.set(target,cloneTarget);
        //如果是数组，赋值为undefined，如果是对象，就取出所有的key
        const keys = isArray ? undefined : Object.keys(target);
        myforEach(keys || target, (value,key)=>{
            if(keys){
                key = value;
            }
            cloneTarget[key] = clone(target[key],map)
        })
        return cloneTarget
    }else{
        return target
    }
}
```

此段代码的运行速度比之前for in快。

##### 拷贝函数

​	实际上拷贝函数是没有实际应用场景的，两个对象使用同一个地址的函数是没有问题的。

可以通过prototype来区分箭头函数和普通函数，箭头函数没有prototype。

判断别的数据类型，更多操作，参考 https://mp.weixin.qq.com/s/vXbFsG59L1Ba0DMcZeU2Bg 

# 43.手写call，apply，bind

# 44.函数柯里化

https://github.com/mqyqingfeng/Blog/issues/42 

​	函数柯里化是将一个多参数的函数转换成多个单参数的函数 的技术。

联系：

​	语法糖：代码可以执行相同作用，但是写起来更简洁，更自然，语义化。

例如：

```js
//有如下数据
var person = [{name: 'kevin'}, {name: 'daisy'}]
//要获取name值
var name = person.map(function (item) {
    return item.name;
})
//使用柯里化
var prop = curry(function (key, obj) {
    return obj[key]
});
var name = person.map(prop('name'))
```

优点：prop函数编写一次后，以后可以多次使用。

偏函数是函数柯里化运算的一种特定应用场景。简单描述，就是把一个函数的某些参数先固化，也就是设置默认值，返回一个新的函数，在新函数中继续接收剩余参数，这样调用这个新函数会更简单。 

# 45.模拟new操作符的实现

```js
//1.创建一个空对象
var obj = {}
//2.链接该对象到另一个对象
obj.__proto__ = Dog.prototype
//3.将this指向新创建的对象
Dog.apply(obj,["小白",2])
//4.如果该函数没有返回对象类型，则返回this
```

```js
var obj = {}
function Dog(name,age){
    //....
    //返回一个对象
    return obj
}
var dog = new Dog("小白",3)
console.log(dog === obj) //true
```

联系：

##### 	执行上下文

​	执行上下文就是js的执行环境，当js执行一段代码时，会创建对应的执行上下文。由于js是单线程，一次只能处理一件事，其他任务会放在指定上下文栈中排队。

​	js解释器在初始化执行代码时，会创建一个全局执行上下文到栈中，随着每次函数的调用都会创建并压入一个新的执行上下文栈。函数执行后，执行上下文被弹出。

# 46.回调函数

回调函数作为参数传递给其他的代码，其作用是在需要的时候调用这段代码。

回调函数有一个致命的弱点，就是容易写出回调地狱(callback hell)，就是多个事件存在依赖性。不利于阅读和维护。所以ES6中提出了Promise和async/await来解决回调地狱的问题。还有别的缺点，如不能使用try catch捕获错误，不能直接return。

# 47.Promise

### 异步解决方案

### 1.回调函数

​	回调函数就是一个函数被作为参数传递给另一个函数，回调不一定就是异步，只不过回调函数是异步的一种解决方案。

```js
function fn1(callback){
    console.log(1)
    callback && callback()
}
function fn2(){
    console.log(2)
}
fn1(fn2)
```

如上，函数fn1作为回调，传入fn2，那么函数fn1执行到callback函数调用就会调用fn2，是同步的。

```js
fn1(callback){
	setTimeout(()=>{
        callback && callback()
    },1000)
}
```

模拟了一个耗时1s的任务，在任务结束时会抛出一个回调。

###### 优点：回调函数是异步编程最基本的方法，简单、容易理解和部署

###### 缺点：不利于代码的阅读和维护，各部分之间高度耦合。层层嵌套造成回调地狱。异步回调中，回调函数的执行栈与原函数分离开，外部无法抓住异常，变得不可控。

### 2.事件监听（发布订阅模式）

​	可以采用事件驱动，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。

1.jQuery中的on监听事件，trigger触发事件

```js
$("body").on("done", fn2)

function fn1() {
  setTimeout(function() {
    $("body").trigger("done")
  }, 2000)
}

function fn2() {
  console.log("fn2执行了")
}
fn1()
```

on可绑定多个事件，每个事件可以指定多个回调。

2.简述发布订阅模式（观察者模式）

​	发布订阅模式，又叫观察者模式，定义了对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知。

最简单的使用：

```js
document.body.addEventListener('click', function () {
  console.log(1)
})
```

发布订阅模式实现事件监听器

```js
class Emitter {
  constructor() {
    // _listener数组，key为自定义事件名，value为执行回调数组-因为可能有多个
    this._listener = []
  }
  // 订阅 监听事件
  on(type, fn) {
    // 判断_listener数组中是否存在该事件命
    // 存在将回调push到事件名对应的value数组中，不存在直接新增
    this._listener[type] 
      ? this._listener[type].push(fn) 
    	: (this._listener[type] = [fn])
  }
  // 发布 触发事件
  trigger(type, ...rest) {
    // 判断该触发事件是否存在
    if (!this._listener[type]) return
    // 遍历执行该事件回调数组并传递参数
    this._listener[type].forEach(callback => callback(...rest))
  }
}
```

使用时：

```js
// 创建一个emitter实例
const emitter = new Emitter()
emitter.on("done", function(arg1, arg2) {
  console.log(arg1, arg2)
})
emitter.on("done", function(arg1, arg2) {
  console.log(arg2, arg1)
})
function fn1() {
  console.log('我是主程序')
  setTimeout(() => {
    emitter.trigger("done", "异步参数一", "异步参数二")
  }, 1000)
}
fn1()

```

###### 优点：发布订阅模式实现的事件监听，可以绑定多个事件，每个事件也可以有多个回调。

###### 缺点：程序变成事件驱动，每次使用需要注册和监听比较麻烦。



### 3.Promise

Promise是解决地狱回调，异步编程的一种解决方案。

​	有以下几种状态：

​		pending：初始状态，既不是成功，也不是失败。

​		resolved/fulfilled：意味着操作成功

​		rejected：意味着操作失败

特点：这个状态一旦从等待状态变为其他状态就永远不能更改了。不受外界影响，只有异步操作结果可以决定当前状态，任何其他操作都无法改变该状态。

一旦状态改变，Promise的then方法就会被调用；否则就会触发catch。

```js
new promise((resolve,reject)=>{
    setTimeout(()=>{
        console.log(1)
        resolve()
    },1000)
}).then((res)=>{
    setTimeout(()=>{
        console.log(2)
    },2000)
}).then((res)=>{
    setTimeout(()=>{
        console.log(3)
    },3000)
}).catch((err)=>{
    console.log(err)
})
```

###### Promise的参数叫处理器函数Executor function。处理器函数接收两个参数，resolve和reject，这两个参数也是两个回调函数。resolve函数在异步操作成功时调用，并将异步操作的结果作为参数传递出去。reject函数在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。

##### Promise.prototype.then()

​	promise对象有一个原型方法then

​	promise实例生成后，可以用then方法指定resolved状态和reject状态的回调函数。

then方法接受两个回调：

​	onFulfilled：当promise变为已完成的状态时调用的回调。有一个参数即接受的最终结果，如果改参数不是函数，会在内部替换为(x) => x，原样返回promise结果的函数

​	onRejected：当Promise变为失败状态时调用的回调

then方法如果返回的是一个普通值，就使用此值包装成一个新的Promise对象返回。

```js
let p =new Promise((resolve,reject)=>{
  resolve(1)
})
p.then(data=>{
  return 2	// 返回了一个普通值
}).then(data=>{
  console.log(data) // 2
})
```

then方法没有return语句，就返回一个用undefined包装的promise对象

```js
let p = new Promise((resolve, reject) => {
  resolve(1)
})
p.then(data => {
  // 无return语句
}).then(data => {
  console.log(data) // undefined
})
```

then方法出现异常，则新promise变为rejected跳转到下一个then的onRejected

1. 

```js
let p = new Promise((resolve, reject) => {
  resolve(1)
})

p.then(data => 2)
  .then(
    data => {
      throw "this is err"
    },
    err => {
      console.log("err1:" + err)
    }
  )
  .then(
    data => {
      console.log(data)
    },
    err => {
      console.log("err2:" + err) // err2:this is err
    }
  )

```

then方法没有传入任何回调，则继续向下传递（值穿透）

```js
let p = new Promise((resolve, reject) => {
  resolve(1)
})
p.then(data => 2)
.then()
.then()
.then(data => {
  console.log(data) // 2
})
```

then方法返回一个promise对象，此promise的结果就会成为新promise的结果

```js
let p = new Promise((resolve, reject) => {
  resolve(1)
})

p.then(data => {
  return new Promise((resolve, reject) => {
    resolve(2)
  })
}).then(data => {
  console.log(data) // 2
})
```

#### 总结：

 promise.then()返回的新promise的结果状态由什么决定?

(1) 简单表达: 由then()指定的回调函数执行的结果决定

(2) 详细表达:

① 如果抛出异常, 新promise变为rejected, reason为抛出的异常

② 如果返回的是非promise的任意值, 新promise变为resolved, value为返回的值

③ 如果返回的是另一个新promise, 此promise的结果就会成为新promise的结果 

##### promise.prototype.catch()

捕获异常，当promise内容代码中抛出错误或者出现rejected就会被捕获。

如果在第一个catch中只return了错误信息，并没有抛出错误或者返回失败的promise，下面接受到的还是resolve。

##### promise.prototype.finally()

```js
p.finally(function(){
    
})
```

在promise结束时，不管成功还是失败都会执行，该回调无参数。

##### promise.resolve()和promise.reject()

接收一个值（可以是任意类型），将该值转为promise对象

##### promise.all()

用于将多个promise实例包装成一个新的promise实例，参数为一组promise实例组成的数组。

iterable代表可迭代对象，Array，Map和Set都属于iterable类型

```js
let p1 = Promise.resolve(1);
let p2 = Promise.resolve(2);
let p3 = Promise.resolve(3);
let p = Promise.all([p1,p2,p3]);
p.then(data=>{
    console.log(data)// [1,2,3] 返回的是promise实例返回值组成的数组
})
```

当所有状态都为resolved的时候，p的状态才会为resolved

当有一个实例状态为rejected，p的状态就为rejected，返回的是第一个rejected中的数据

##### promise.race()

all方法是迭代对象中状态全部改变才执行。

race方法是迭代对象第一个完成的promise的结果状态就是它最终的结果状态。

```js
const p1 = new Promise((resolve, reject) => {
  setTimeout(resolve, 1000, "1")
})

const p2 = new Promise((resolve, reject) => {
  setTimeout(resolve, 500, "2")
})

Promise.race([p1, p2])
  .then(value => {
    console.log(value) // 2
  })
```

##### promise.try()

当要用promise来处理一个函数，可以使用Promise.resolve转为promise对象。

但是如果函数为同步的，这样会将它转为异步，想让同步函数同步执行，异步函数异步执行，可以使用try方法。

```js
const fn = () => console.log("fn");
Promise.try(fn)
  .then(() => {
    console.log(222)
  })
  .catch(err => {
    console.log(err)
  })

console.log("111")

// fn
// 111
// 222

```

但是该方法在js中不可以使用，使用的话需要使用promise库，bluebird，Q或者引入polyfill



##### 中断链式调用

 在链式调用中，返回一个pending 状态或reject状态的Promise对象即可 

```js
Promise.resolve()
	.then(()=>{
  	console.log(a)
  	console.log("Task 1");
	})
  .then(()=>{
  	console.log("Task 2");
	})
  .catch((err)=>{
  	console.log("err:" + err)
	})
  .then(()=>{
  	console.log("finaltask")
	});

// err:ReferenceError: a is not defined
// finaltask

```

返回reject状态后如果想要继续执行某个then，需要在上面catch捕获到错误，下面的就可以继续执行了。



##### 异步回调中抛错catch捕获不到

```js
//可以捕获到
const p = new Promise((resolve, reject)=>{
  throw new Error('这是一个错误')
});
p.catch((error)=>{ console.log(error) });
```

```js
//捕获不到
const p = new Promise((resolve, reject)=>{
  setTimeout(()=>{ throw new Error('这是一个错误') }, 0)
});
p.catch((error)=>{ console.log(error) });
```

###### 原因：

​	setTimeout是宏任务，promise是微任务。

​	1.代码执行栈进入promise触发setTimeout，setTimeout回调函数进入宏任务队列。

​	2.代码执行promise的catch方法，入微队列任务

​	3.执行栈先执行微任务catch，然后执行宏任务。	

###### 解决：

使用try catch捕获异常主动触发reject

```js
const p = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        try{
            throw new Error("错误")
        }catch(e){
            reject(e)
        }
    },0)
})
p.catch((err)=>console.log(err))
```

### 手写Promise，符合Promise/A+规范

promise/A+标准是一个开发健全且通用的promise规范

规范：

​	Promise有三种状态进行中 (Pending)、已完成 (Resolved/Fulfilled)和已失败 (Rejected)

​	Promise是一个构造方法，实例化Promise时传入一个函数作为处理器 

​	处理器函数有两个参数(resolve和reject)分别将结果变为成功态和失败态

​	Promise对象执行成功了要有一个结果，通过resolve传递出去，失败的话失败原因通过reject传递出入

​	Promise的原型上定义着then方法

```js
function Promise(executor){
    //状态描述
    this.state = "pending"
    this.value = undefined
    this.reason = undefined
    function resolve(value){
        
    }
    function reject(value){
        
    }
}
Promise.prototype.then = function(onFulfilled,onRejected){}
```

初始化实例executor立即执行

在创建promise实例时，处理器函数executor是会立即执行的。

```js
function Promise(executor){
    this.state = "pending"
    this.value = undefined
    this.reason = undefined
   	//立即执行处理器函数
    try{
        executor(resolve,reject)
    }catch(err){
        reject(err)
    }
    function resolve(value){}
    function reject(reason){}
}
```

规范：

​	当Promise对象已经由pending状态改变为成功态(resolved)或失败态(rejected)后不可再次更改状态

因此更新状态时要判断，当前是pending才可更新。所以需要完善resolve和reject方法

```js
let _this = this
function resolve(value){
    if(_this.state === "pending"){
        _this.value = value
        _this.state = "resovled"
    }
}
function reject(reason){
    if(_this.state === "pending"){
        _this.reason = reason
        _this.state = "rejected"
    }
}
//只有pending状态才可进行状态更改操作，
//将成功和失败的结果都保存到属性上，然后重置更新后的状态
```

then方法基础实现

```js
Promise.prototype.then = function(onFulfilled, onRejected){
    if(this.state === "resolved"){
        if(typeof onFulfilled === "function"){
            onFulfilled(this.value)
        }
    }
    if(this.state === "rejected"){
        if(typeof onRejected === "function"){
            onRejected(this.reason)
        }
    }
}
//由于两个参数都不是必选餐，所以在判断状态后又判断了参数类型，当不为函数类型，就不执行。
```

让Promise支持异步

在执行then方法时如果还在pending状态，就把回调函数临时寄存在队列里（就是一个数组里），当状态改变时从数组中取出执行。

```js
//在构造方法中新增两个Array数组，存放成功和失败的回调函数
function Promise(executor){
    //...
    this.onResovledCallbacks = []
    this.onRejectedCallbacks = []
}
```

在then方法执行时，如果是pending，就将回调存入数组

```js
Promise.prototype.then = function(onFulfilled, onRejected){
    if(this.state === "resolved"){
        if(typeof onFulfilled === "function"){
            onFulfilled(this.value)
        }
    }
    if(this.state === "rejected"){
        if(typeof onRejected === "function"){
            onRejected(this.reason)
        }
    }
    //新增等待状态
    if(this.state === "pending"){
        if(typeof onFulfilled === "function"){
            this.onResovledCallbacks.push(onFulfilled
        }
        if (typeof onRejected === "function") {
            this.onRejectedCallbacks.push(onRejected)
        }                                   
    }
}
```

在resolve和reject方法中调用

```js
function resolve(value) {
  if (_this.state === 'pending') {
    _this.value = value
    // 遍历执行成功回调
    _this.onResolvedCallbacks.forEach(cb => cb(value))
    _this.state = 'resolved'
  }
}
function reject(reason) {
  if (_this.state === 'pending') {
    _this.reason = reason
    // 遍历执行失败回调
    _this.onRejectedCallbacks.forEach(cb => cb(reason))
    _this.state = 'rejected'
  }
}
```

实现promise的链式调用

​	首先then 方法必须返回一个 promise 对象(划重点)


​	如果then方法中返回的是一个普通值(如Number、String等)就使用此值包装成一个新的Promise对象返回


​	如果then方法中没有return语句，就返回一个用Undefined包装的Promise对象


​	如果then方法中出现异常，则调用失败态方法(reject)跳转到下一个then的onRejected


​	如果then方法没有传入任何回调，则继续向下传递(值穿透)

​	如果then方法中返回了一个Promise对象，那就以这个对象为准，返回它的结果

```js
//需求中说如果then方法没有传入任何回调，则继续向下传递，但是每个then中又返回一个新的Promise，也就是说当then方法中没有回调时，我们需要把接收到的值继续向下传递，这个其实好办，只需要在判断回调参数不为函数时我们把他变成回调函数返回普通值即可
//then实现中，在每个可执行处都加了参数是否为函数的类型校验，但是我们这里在then方法开头统一做了校验，就不需要参数校验了
//现在then变成了如下代码，
Promise.prototype.then = function(onFulfilled, onRejected) {
  onFulfilled = typeof onFulfilled === "function" ? onFulfilled : value => value
  onRejected = typeof onRejected === "function" ? onRejected : err => { throw err }
	
  if (this.state === "pending") {
    this.onResolvedCallbacks.push(onFulfilled)
    this.onRejectedCallbacks.push(onRejected)
  }
  
  if (this.state === "resolved") {
    onFulfilled(this.value)
  }
  if (this.state === "rejected") {
    onRejected(this.reason)
  }
}
```

每个then都返回一个新的promise

```js
Promise.prototype.then = function(onFulfilled, onRejected) {
  onFulfilled = typeof onFulfilled === "function" ? onFulfilled : value => value
  onRejected = typeof onRejected === "function" ? onRejected : err => { throw err }
  
  let promise2 = new Promise((resolve, reject) => {
   	if (this.state === "pending") {
      this.onResolvedCallbacks.push(onFulfilled)
      this.onRejectedCallbacks.push(onRejected)
    }

    if (this.state === "resolved") {
      onFulfilled(this.value)
    }
    if (this.state === "rejected") {
      onRejected(this.reason)
    }
  })
  return promise2
}
```

接着在每个执行函数里写try catch语法，try中执行resolve结果，catch执行reject

```js
if (this.state === "resolved") {
  try {
    // 拿到返回值resolve出去
    let x = onFulfilled(this.value)
    resolve(x)
  } catch (e) {
    // catch捕获异常reject抛出
    reject(e)
  }
}
```

pending状态判断和resolved相似

```js 
if (this.state === "pending") {
  // push(onFulfilled)
  // push(()=>{ onFulfilled() })
  // 上面两种执行效果一致，后者可在回调中加一些其他功能，如下
  this.onResolvedCallbacks.push(() => {
    try {
      let x = onFulfilled(this.value)
      resolve(x)
    } catch (e) {
      reject(e)
    }
  })
  this.onRejectedCallbacks.push(() => {
    try {
      let x = onRejected(this.value)
      resolve(x)
    } catch (e) {
      reject(e)
    }
  })
}
```

处理上一个then方法返回的新promise对象

抽离出一个方法来做这件事

```js
function resolvePromise(promise2,x,resolve,reject){
    //promise2:新的promise实例
    //x:上一个then的返回值
    //resolve：promise2处理器函数的resolve
}
```

避免循环引用：当then的返回值与新的Promise对象为同一个，则抛出TypeError错误

比如：

```js
let promise2 = p.then(data => {
    return promise2;
})
// TypeError: Chaining cycle detected for promise #<Promise>
```

如果返回的是自身，则状态永远为pending，所以要先处理它

```js
function resolvePromise(promise2,x,resolve,reject){
    if(promise2 === x){
        reject(new TypeError("避免promise循环引用"))
    }
}
```

当x是一个对象或者函数，再进一步处理，否则是一个普通值

```js
function resolvePromise(promise2, x, resolve, reject) {
  if (promise2 === x) {
    reject(new TypeError('请避免Promise循环引用'))
  }

  if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
    // 可能是个对象或是函数
  } else {
    // 是个普通值
    resolve(x)
  }
}
```

如果x是对象，将对象上的then方法取出来，如果报错，就catch为reject

```js
// resolvePromise方法内部片段
if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
  // 可能是个对象或是函数
  try {
    // 尝试取出then方法引用
    let then = x.then
  } catch (e) {
    reject(e)
  }
} else {
  // 是个普通值
  resolve(x)
}
```

如果对象中有then,且then是函数类型，就可以认为是一个promise对象，使用x作为其this来调用then方法

```js
if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
  // 可能是个对象或是函数
  try {
    // 尝试取出then方法引用
    let then = x.then
    if (typeof then === 'function') {
      // then是function，那么执行Promise
      then.call(x, (y) => {
        resolve(y)
      }, (r) => {
        reject(r);
      })
    } else {
      resolve(x)
    }
  } catch (e) {
    reject(e)
  }
} else {
  // 是个普通值
  resolve(x)
}
```

如果promise对象转为成功或失败时传入的还是一个promise，就应该继续执行

例如：

```js
Promise.resolve(1).then(data => {
  return new Promise((resolve,reject)=>{
    // resolve传入的还是Promise
    resolve(new Promise((resolve,reject)=>{
      resolve(2)
    }))
  })
})
```

这种情况，采用递归，把调用resolve改为递归执行resolvePromise

```js
// then是function，那么执行Promise
then.call(x, (y) => {
	// 递归调用，传入y若是Promise对象，继续循环
    resolvePromise(promise2, y, resolve, reject)
}, (r) => {
	reject(r);
})
```

 规范中定义，如果resolvePromise和rejectPromise都被调用，或者多次调用同一个参数，第一个调用优先，任何进一步的调用都将被忽略，为了让成功和失败只能调用一个，接着完善，设定一个called来防止多次调用 

```js
// resolvePromise方法内部片段
let called
if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
  // 可能是个对象或是函数
  try {
    let then = x.then
    if (typeof then === 'function') {
      then.call(x, (y) => {
        if (called) return
        called = true
        // 递归调用，传入y若是Promise对象，继续循环
        resolvePromise(promise2, y, resolve, reject)
      }, (r) => {
        if (called) return
        called = true
        reject(r)
      })
    } else {
      resolve(x)
    }
  } catch (e) {
    if (called) return
    called = true
    reject(e)
  }
} else {
  // 普通值结束递归
  resolve(x)
}
```

promise中处理器函数是同步执行，而then是异步，但是此时是同步。

市面上大多数promise库的做法，是使用setTimeout模拟，在then方法内执行处的所有地方使用setTimeout变为异步即可，只是这样做和浏览器自带的promise的区别就是浏览器的promise.then是微任务，用setTimeout实现的是宏任务。不过这也是大多数promise库的做法。

```js
setTimeout(() => {
  try {
    let x = onFulfilled(value);
    resolvePromise(promise2, x, resolve, reject)
  } catch (e) {
    reject(e);
  }
},0)
```

##### 终极版的then方法

```js
Promise.prototype.then = function(onFulfilled, onRejected) {
  onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value
  onRejected = typeof onRejected === 'function' ? onRejected : err => { throw err }
  
  let promise2 = new Promise((resolve, reject) => {
    // 等待态判断，此时异步代码还未走完，回调入数组队列
    if (this.state === "pending") {
      this.onResolvedCallbacks.push(() => {
        setTimeout(() => {
          try {
            let x = onFulfilled(this.value)
            resolvePromise(promise2, x, resolve, reject)
          } catch (e) {
            reject(e)
          }
        }, 0)
      })

      this.onRejectedCallbacks.push(() => {
        setTimeout(() => {
          try {
            let x = onRejected(this.reason)
            resolvePromise(promise2, x, resolve, reject)
          } catch (e) {
            reject(e)
          }
        }, 0)
      })
    }
    if (this.state === "resolved") {
      setTimeout(() => {
        try {
          let x = onFulfilled(this.value)
          resolvePromise(promise2, x, resolve, reject)
        } catch (e) {
          reject(e)
        }
      }, 0)
    }
    if (this.state === "rejected") {
      setTimeout(() => {
        try {
          let x = onRejected(this.reason)
          resolvePromise(promise2, x, resolve, reject)
        } catch (e) {
          reject(e)
        }
      }, 0)
    }
  })
  return promise2
}
```

##### Promise.prototype.catch实现

```js
Promise.prototype.catch = function(onRejected){
    return this.then(null,onRejected)
}
```

##### Promise.resolve实现

```js
Promise.resolve = function(value){
    //返回一个 Promise 对象
    return new Promise((resolve, reject)=>{
        if(value instanceof Promise){
            //value 的结果 决定返回Promise的结果
            value.then(resolve, reject);
        }else{
            resolve(value);
        }
    });
}
```

##### Promise.reject实现

```js
Promise.reject = function (reason) {
    return new Promise((resolve, reject) => {
        reject(reason);
    });
}
```

##### Promise.all实现

```js
//获取到所有的promise，都执行then，把结果放到数组，一起返回。
Promise.all = function(arr){
    //存放每次执行后的返回结果
    let aResult = []
    return new Promise(function(resolve,resject){
        let i = 0
        //逐次执行数组中的函数
        next()
        function next(){
            arr[i].then(value=>{
                aResult.push(value)
                i++
                if(i>=arr.length){
                    resolve(aResult)
                }else{
                    next()
                }
            },reason=>{
                reject(reason)
            })
        }
    })
}
```

##### promise.race实现

```js
Promise.race = function(arr){
    return new Promise((resolve,reject)=>{
        for(let i = 0; i < arr.length; i++){
            arr[i].then(value=>{
                reslove(value)
            },reason=>{
                reject(reason)
            })
        }
    })
}
```

### 5.Async/Await(异步等待)

async/await是generator的语法糖。可以理解为 Async/Await = Generator + Promise 

#### 1.asyn

```js
async function test(){
    return "this is async"
}
const res = test()
console.log(res)// Promise {<resolved>: "this is async"}
```

async函数返回的是一个Promise对象，如果在async函数中直接return一个直接量，async会把这个直接量通过Promise.resolve()封装成Promise对象返回。

既然async返回一个Promise，那么可以调用then。

#### 2.await

常说await在等待一个异步完成，按照语法说明，await等待的是一个表达式，这个表达式的计算结果是promise对象或者其他值。

​	await后面不是promise，直接执行。

​	await后面是Promise对象会阻塞后面的代码，得到resolve的值后，作为await表达式的结果。

​	await只能在async函数中使用。

##### 为什么await必须在async函数中使用？

​	await会阻塞后面代码。如果直接使用await的话，假如我们使用await等待一个时间消耗很长的异步请求，那代码直接阻塞不往下进行了，只能等待await拿到结果。而async函数调用不会造成阻塞，因为它内部所有的阻塞都被封装在一个promise对象中异步执行。

##### 处理异常

​	promise正常resolve，那么await会返回这个结果，但是在reject情况下会抛出一个错误，所以要把await代码写到try catch中。

```js
function fn1(){
    return new Promise((resolve,reject)=>{
        reject("失败")
    })
}
async function fn(){
    try {
        let res = await fn1()
        console.log(res);
    } catch (error) {
        console.log(error);
    }

}
fn()
```

##### 优点：

​	内置执行器，generator函数执行必须靠执行器，	所以才有了co函数库（ 用于 Generator 函数的自动执行 ），而async函数自带执行器。

​	更好的语义，async和await，比起*和yield，语义更清楚，async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。

​	更广的使用性， co 函数库约定，`yield` 命令后面只能是 Thunk 函数或 Promise 对象， 而async函数的await命令后面，可以跟promise对象和原始类型的值。

##### 缺点：

​	滥用await可能会导致性能问题，因为await会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。

# 48.instanceof原理

instanceof可以正确判断对象的类型，因为内部机制是通过判断对象的原型链中是否能找到类型的prototype。

实现：

​	1.获取类型的原型

​	2.获得对象的原型

​	3.然后一直循环判断对象的原型是否等于类型的原型，知道对象原型为null。

```js
function myInstanceof(left,right){
    let prototype = right.prototype
    left = left.__proto__
    while(true){
        if(left === null || left === undefined) return false
        if(prototype ===left) return true
        left = left.__proto__
    }
}
```

# 49.js的节流和防抖

##### 事件频繁触发会产生的问题？

​	一些浏览器事件，onresize,mousemove频繁触发会造成浏览器性能问题。

​	向后台频繁发送请求，会对服务器造成压力。

##### 函数节流：

​	在函数需要频繁触发时，函数执行一次后，大于设定的时间后，才执行第二次。适合多次事件按时间平均分配触发。

​	场景：resize   scroll  mousemove  click

##### 函数防抖：

​	在函数需要频繁触发时，在规定时间内（当时间内再次执行，会重新计时），只让最后一次生效，前面的不生效，适合多次事件一次响应的情况。

​	场景：输入框实时搜索联想（在连续快速输入很多字符后，只让最后一次发请求）    

``` js
//函数防抖的实现
function debounce(fn,wait){
    var timer = null;
    return function(){
        var context = this,
        var args = arguments
        //如果此时存在定时器的话，则取消之前的定时器重新计时
        if(timer){
            clearTimeout(timer);
            timer = null;
        }
        //设置定时器，使事件间隔指定时间后执行
        timer = setTimeout(()=>{
            fn.apply(context,args)
        },wait)
    }
}

//函数节流的实现
function throttle(fn,delay){
    var preTime = Date.now();
    return function(){
        var context = this
        var args = arguments
        var nowTime = Date.now()
        //如果两次事件间隔超过了指定时间，则执行函数
        if(nowTime - preTime >= delay){
            preTime = Date.now()
            return fn.apply(context,args)
        }
    }
}
```

# 50.设计模式

使用设计模式为了重用代码，让代码更容易被他人理解，保证代码可靠性。使代码真正工程化。

#### 设计原则

##### 	1. SRP-Single Responsibility Principle 单一职责原则

​		一个程序只做好一件事

​		如果功能过于复杂就拆分开，每个部分保持独立

##### 	2. OCP-OpenClosed Principle 开放/封闭原则

​		对扩展开放，对修改封闭

​		增加需求时，扩展新代码，而非修改已有代码

##### 	3. LSP-Liskov Subsitution Principle 里氏替换原则

​		子类可以扩展父类的功能，但不能改变父类原有的功能

##### 	4. ISP-Interface Segregation Principle 接口隔离原则

​		保持接口的单一独立

​		类似单一职责原则，这里更关注接口

##### 	5. DIP-Dependency Inversion Principle 依赖倒转原则

​		面向接口编程，不应该面向实现类编程

​		使用方只关注接口而不关注具体类的实现s

##### 	6. LKP - Least Konwledge Principle 最少知识原则

​		又叫迪米特法则，核心思想：低耦合，高内聚

​		系统功能模块相对独立，尽可能少的与其他模块相互作用

#### 设计模式的类型

##### 	结构型模式（Structural Patterns）：

​		通过识别系统中组件间的简单关系来简化系统的设计。

##### 	创建型模式（Creational Patterns）:

​		处理对象的窗口，根据实际情况使用合适的方式创建对象。常规的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。

##### 	行为型模式（Behavioral Patterns）:

​		用于识别对象之间常见的交互模式并加以实现，如此，增加了这些交互的灵活性。







